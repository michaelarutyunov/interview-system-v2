# Spec 6.4: Error Handling

## Objective
Review and ensure comprehensive error handling throughout the codebase.

## Context
- Reference: ENGINEERING_GUIDE.md Section 7 (Error Handling)
- FastAPI exception handlers for consistent error responses
- Custom exceptions for domain-specific errors
- Graceful degradation where appropriate

## Input Files
- `src/core/exceptions.py` - Custom exception definitions
- ENGINEERING_GUIDE.md Section 7

## Output Files

### src/core/exceptions.py (update)
```python
"""
Custom exceptions for the interview system.

Provides domain-specific exceptions with consistent error handling.
"""

from typing import Optional, Dict, Any


class InterviewSystemError(Exception):
    """Base exception for all application errors."""
    
    def __init__(
        self,
        message: str,
        details: Optional[Dict[str, Any]] = None,
    ):
        """
        Initialize exception.
        
        Args:
            message: Human-readable error message
            details: Optional additional error details
        """
        self.message = message
        self.details = details or {}
        super().__init__(self.message)


class ConfigurationError(InterviewSystemError):
    """Invalid configuration."""
    pass


class LLMError(InterviewSystemError):
    """Base for LLM-related errors."""
    pass


class LLMTimeoutError(LLMError):
    """LLM call timed out."""
    pass


class LLMRateLimitError(LLMError):
    """LLM rate limit exceeded."""
    pass


class LLMInvalidResponseError(LLMError):
    """LLM returned invalid/unparseable response."""
    pass


class ExtractionError(InterviewSystemError):
    """Failed to extract concepts from response."""
    pass


class SessionError(InterviewSystemError):
    """Base for session-related errors."""
    pass


class SessionNotFoundError(SessionError):
    """Session does not exist."""
    pass


class SessionCompletedError(SessionError):
    """Attempted operation on completed session."""
    pass


class ValidationError(InterviewSystemError):
    """Input validation failed."""
    pass


class GraphError(InterviewSystemError):
    """Knowledge graph related error."""
    pass
```

### src/api/exception_handlers.py
```python
"""
Global exception handlers for FastAPI.

Provides consistent error responses across all endpoints.
"""

from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse

import structlog

from src.core.exceptions import (
    InterviewSystemError,
    ConfigurationError,
    LLMError,
    LLMTimeoutError,
    LLMRateLimitError,
    SessionNotFoundError,
    SessionCompletedError,
    ValidationError,
)


log = structlog.get_logger(__name__)


def setup_exception_handlers(app: FastAPI):
    """
    Register all exception handlers with the FastAPI app.
    
    Args:
        app: FastAPI application instance
    """
    
    @app.exception_handler(InterviewSystemError)
    async def interview_system_error_handler(
        request: Request,
        exc: InterviewSystemError,
    ) -> JSONResponse:
        """Handle all custom InterviewSystemError exceptions."""
        log_ctx = log.bind(
            path=request.url.path,
            method=request.method,
            error_type=type(exc).__name__,
        )
        
        # Determine status code based on exception type
        status_code = status.HTTP_500_INTERNAL_SERVER_ERROR
        
        if isinstance(exc, SessionNotFoundError):
            status_code = status.HTTP_404_NOT_FOUND
        elif isinstance(exc, ValidationError):
            status_code = status.HTTP_400_BAD_REQUEST
        elif isinstance(exc, SessionCompletedError):
            status_code = status.HTTP_400_BAD_REQUEST
        elif isinstance(exc, LLMTimeoutError):
            status_code = status.HTTP_504_GATEWAY_TIMEOUT
        elif isinstance(exc, LLMRateLimitError):
            status_code = status.HTTP_429_TOO_MANY_REQUESTS
        
        log_ctx.warning(
            "request_error",
            message=exc.message,
            status_code=status_code,
            details=exc.details,
        )
        
        return JSONResponse(
            status_code=status_code,
            content={
                "error": {
                    "type": type(exc).__name__,
                    "message": exc.message,
                    "details": exc.details,
                }
            },
        )
    
    @app.exception_handler(ConfigurationError)
    async def configuration_error_handler(
        request: Request,
        exc: ConfigurationError,
    ) -> JSONResponse:
        """Handle configuration errors."""
        log.error(
            "configuration_error",
            path=request.url.path,
            message=exc.message,
        )
        
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "error": {
                    "type": "ConfigurationError",
                    "message": "Server configuration error",
                    "details": exc.message if log.level <= 10 else None,  # Only in debug
                }
            },
        )
    
    @app.exception_handler(Exception)
    async def generic_exception_handler(
        request: Request,
        exc: Exception,
    ) -> JSONResponse:
        """Handle all unhandled exceptions."""
        log_ctx = log.bind(
            path=request.url.path,
            method=request.method,
            error_type=type(exc).__name__,
        )
        
        log_ctx.error(
            "unhandled_exception",
            message=str(exc),
            exc_info=exc,
        )
        
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content={
                "error": {
                    "type": "InternalServerError",
                    "message": "An unexpected error occurred",
                }
            },
        )
```

### src/main.py (update)
```python
# Add to main.py after app creation

from src.api.exception_handlers import setup_exception_handlers

# Setup exception handlers
setup_exception_handlers(app)
```

### tests/unit/test_exception_handlers.py
```python
"""Tests for exception handlers."""

import pytest
from fastapi import FastAPI, Request
from fastapi.testclient import TestClient

from src.api.exception_handlers import setup_exception_handlers
from src.core.exceptions import (
    SessionNotFoundError,
    SessionCompletedError,
    ValidationError,
    LLMTimeoutError,
)


def test_session_not_found_returns_404():
    """SessionNotFoundError returns 404 status."""
    app = FastAPI()
    setup_exception_handlers(app)
    
    @app.get("/test")
    async def test_route():
        raise SessionNotFoundError("Session not found")
    
    client = TestClient(app)
    response = client.get("/test")
    
    assert response.status_code == 404
    data = response.json()
    assert "error" in data
    assert data["error"]["type"] == "SessionNotFoundError"


def test_validation_error_returns_400():
    """ValidationError returns 400 status."""
    app = FastAPI()
    setup_exception_handlers(app)
    
    @app.get("/test")
    async def test_route():
        raise ValidationError("Invalid input")
    
    client = TestClient(app)
    response = client.get("/test")
    
    assert response.status_code == 400
    data = response.json()
    assert "error" in data


def test_llm_timeout_returns_504():
    """LLMTimeoutError returns 504 status."""
    app = FastAPI()
    setup_exception_handlers(app)
    
    @app.get("/test")
    async def test_route():
        raise LLMTimeoutError("LLM request timed out")
    
    client = TestClient(app)
    response = client.get("/test")
    
    assert response.status_code == 504


def test_generic_exception_returns_500():
    """Unhandled exceptions return 500 status."""
    app = FastAPI()
    setup_exception_handlers(app)
    
    @app.get("/test")
    async def test_route():
        raise ValueError("Unexpected error")
    
    client = TestClient(app)
    response = client.get("/test")
    
    assert response.status_code == 500
    data = response.json()
    assert data["error"]["type"] == "InternalServerError"
```

### docs/error_handling_checklist.md
```markdown
# Error Handling Checklist

Use this checklist to verify error handling is comprehensive.

## Service Layer

- [ ] All services have try/except for external calls
- [ ] LLM errors handled with degradation
- [ ] Database errors logged and re-raised
- [ ] Invalid inputs raise ValidationError
- [ ] Missing entities raise NotFoundError

## API Layer

- [ ] Exception handlers registered in main.py
- [ ] Consistent error response format
- [ ] Appropriate HTTP status codes
- [ ] Sensitive details hidden in production

## Frontend/UI

- [ ] API errors displayed to users
- [ ] Loading states for async operations
- [ ] Timeout handling
- [ ] Network failure handling
```

## Requirements
1. Custom exceptions for all domain errors
2. Global exception handlers in FastAPI
3. Consistent error response format
4. Appropriate HTTP status codes
5. Logging of all errors with context
6. Tests for exception handlers

## Verification
```bash
# Run tests
pytest tests/unit/test_exception_handlers.py -v

# Verify imports
python3 -c "from src.core.exceptions import *; from src.api.exception_handlers import setup_exception_handlers; print('OK')"

# Check exception handlers are in main.py
grep -q "setup_exception_handlers" src/main.py && echo "OK" || echo "Not found"
```

## Success Criteria
- [ ] `src/core/exceptions.py` with all custom exceptions
- [ ] `src/api/exception_handlers.py` with global handlers
- [ ] `setup_exception_handlers()` called in main.py
- [ ] Consistent error response format
- [ ] Appropriate HTTP status codes for each error type
- [ ] All errors logged with context
- [ ] Tests verify error handling behavior
