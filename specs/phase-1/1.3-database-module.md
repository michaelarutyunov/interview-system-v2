# Spec 1.3: Database Module

## Objective
Create the async SQLite database connection management module with initialization and migration support.

## Context
- Reference: ENGINEERING_GUIDE.md Section 2.1 (aiosqlite)
- This module provides the foundation for all database operations

## Input Files
- `ENGINEERING_GUIDE.md` - Database patterns
- `specs/phase-1/1.2-sqlite-schema.md` - Schema to apply

## Output Files

### src/persistence/database.py
```python
"""
SQLite database connection management.

Provides async database initialization, connection factory, and migration support.
Uses aiosqlite for async SQLite access.
"""

import aiosqlite
from pathlib import Path
from typing import AsyncGenerator
import structlog

from src.core.config import settings

log = structlog.get_logger(__name__)

# Path to migrations directory
MIGRATIONS_DIR = Path(__file__).parent / "migrations"


async def init_database(db_path: Path | None = None) -> None:
    """
    Initialize database and run migrations.
    
    Args:
        db_path: Optional path to database file. Uses settings.database_path if not provided.
    
    Creates the database file if it doesn't exist and applies all migrations.
    """
    db_path = db_path or settings.database_path
    
    # Ensure parent directory exists
    db_path.parent.mkdir(parents=True, exist_ok=True)
    
    log.info("initializing_database", path=str(db_path))
    
    async with aiosqlite.connect(db_path) as db:
        # Enable foreign keys
        await db.execute("PRAGMA foreign_keys = ON")
        
        # Enable WAL mode for better concurrent read performance
        await db.execute("PRAGMA journal_mode = WAL")
        
        # Run migrations
        await _run_migrations(db)
        
        await db.commit()
    
    log.info("database_initialized", path=str(db_path))


async def _run_migrations(db: aiosqlite.Connection) -> None:
    """
    Run all SQL migration files in order.
    
    Migrations are .sql files in the migrations directory, sorted by name.
    Each migration is run in full (no partial migration tracking for simplicity).
    """
    if not MIGRATIONS_DIR.exists():
        log.warning("migrations_dir_not_found", path=str(MIGRATIONS_DIR))
        return
    
    migration_files = sorted(MIGRATIONS_DIR.glob("*.sql"))
    
    for migration_file in migration_files:
        log.debug("running_migration", file=migration_file.name)
        
        sql = migration_file.read_text()
        
        # Execute all statements in the migration
        await db.executescript(sql)
    
    log.info("migrations_complete", count=len(migration_files))


async def get_db() -> AsyncGenerator[aiosqlite.Connection, None]:
    """
    Async generator that yields a database connection.
    
    Use as a FastAPI dependency:
    
        @app.get("/sessions")
        async def list_sessions(db: aiosqlite.Connection = Depends(get_db)):
            ...
    
    The connection is automatically closed when the request completes.
    """
    db = await aiosqlite.connect(settings.database_path)
    
    try:
        # Enable foreign keys for this connection
        await db.execute("PRAGMA foreign_keys = ON")
        
        # Use Row factory for dict-like access
        db.row_factory = aiosqlite.Row
        
        yield db
    finally:
        await db.close()


async def get_db_connection() -> aiosqlite.Connection:
    """
    Get a single database connection (for non-FastAPI contexts).
    
    Caller is responsible for closing the connection:
    
        db = await get_db_connection()
        try:
            # use db
        finally:
            await db.close()
    """
    db = await aiosqlite.connect(settings.database_path)
    await db.execute("PRAGMA foreign_keys = ON")
    db.row_factory = aiosqlite.Row
    return db


async def check_database_health() -> dict:
    """
    Check database health for health endpoint.
    
    Returns:
        Dict with health status and basic metrics.
    """
    try:
        async with aiosqlite.connect(settings.database_path) as db:
            # Check we can query
            cursor = await db.execute("SELECT COUNT(*) FROM sessions")
            row = await cursor.fetchone()
            session_count = row[0] if row else 0
            
            # Check integrity
            cursor = await db.execute("PRAGMA integrity_check")
            integrity = await cursor.fetchone()
            
            return {
                "status": "healthy",
                "session_count": session_count,
                "integrity": integrity[0] if integrity else "unknown",
                "path": str(settings.database_path)
            }
    except Exception as e:
        log.error("database_health_check_failed", error=str(e))
        return {
            "status": "unhealthy",
            "error": str(e)
        }
```

### tests/unit/test_database.py
```python
"""Tests for database module."""

import pytest
import tempfile
from pathlib import Path

from src.persistence.database import init_database, get_db_connection, check_database_health


@pytest.mark.asyncio
async def test_init_database_creates_file():
    """Database initialization creates the database file."""
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = Path(tmpdir) / "test.db"
        
        assert not db_path.exists()
        
        await init_database(db_path)
        
        assert db_path.exists()


@pytest.mark.asyncio
async def test_init_database_creates_tables():
    """Database initialization creates all required tables."""
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = Path(tmpdir) / "test.db"
        await init_database(db_path)
        
        import aiosqlite
        async with aiosqlite.connect(db_path) as db:
            cursor = await db.execute(
                "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
            )
            tables = [row[0] for row in await cursor.fetchall()]
        
        assert "sessions" in tables
        assert "utterances" in tables
        assert "kg_nodes" in tables
        assert "kg_edges" in tables
        assert "scoring_history" in tables
        assert "concept_elements" in tables


@pytest.mark.asyncio
async def test_get_db_connection():
    """get_db_connection returns a usable connection."""
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = Path(tmpdir) / "test.db"
        await init_database(db_path)
        
        # Temporarily override settings
        from src.core import config
        original_path = config.settings.database_path
        config.settings.database_path = db_path
        
        try:
            db = await get_db_connection()
            try:
                cursor = await db.execute("SELECT 1")
                row = await cursor.fetchone()
                assert row[0] == 1
            finally:
                await db.close()
        finally:
            config.settings.database_path = original_path


@pytest.mark.asyncio
async def test_check_database_health():
    """Health check returns status information."""
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = Path(tmpdir) / "test.db"
        await init_database(db_path)
        
        from src.core import config
        original_path = config.settings.database_path
        config.settings.database_path = db_path
        
        try:
            health = await check_database_health()
            
            assert health["status"] == "healthy"
            assert health["integrity"] == "ok"
            assert health["session_count"] == 0
        finally:
            config.settings.database_path = original_path


@pytest.mark.asyncio
async def test_foreign_keys_enforced():
    """Foreign key constraints are enforced."""
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = Path(tmpdir) / "test.db"
        await init_database(db_path)
        
        import aiosqlite
        async with aiosqlite.connect(db_path) as db:
            await db.execute("PRAGMA foreign_keys = ON")
            
            # Try to insert utterance with non-existent session
            with pytest.raises(aiosqlite.IntegrityError):
                await db.execute(
                    "INSERT INTO utterances (id, session_id, turn_number, speaker, text) "
                    "VALUES ('u1', 'nonexistent', 1, 'user', 'test')"
                )
```

## Requirements
1. Must use aiosqlite for all database operations
2. Must enable foreign keys on every connection
3. Must enable WAL mode for better performance
4. Must use Row factory for dict-like access
5. Must provide FastAPI-compatible dependency injection via `get_db()`
6. Must handle missing migrations directory gracefully
7. Must create parent directories for database file

## Verification
```bash
cd /path/to/interview-system-v2

# Run the tests
pytest tests/unit/test_database.py -v

# Expected output:
# test_init_database_creates_file PASSED
# test_init_database_creates_tables PASSED
# test_get_db_connection PASSED
# test_check_database_health PASSED
# test_foreign_keys_enforced PASSED
```

## Success Criteria
- [ ] `init_database()` creates database file and runs migrations
- [ ] `get_db()` provides async generator for FastAPI dependency injection
- [ ] `get_db_connection()` provides standalone connection
- [ ] `check_database_health()` returns health status
- [ ] Foreign keys are enforced
- [ ] WAL mode is enabled
- [ ] All tests pass
