# Spec 1.8: Integration Test

## Objective
Create integration tests that verify the Phase 1 deliverable: `POST /sessions`, `GET /sessions/{id}`, `DELETE /sessions/{id}` endpoints working end-to-end.

## Context
- Reference: IMPLEMENTATION_PLAN.md Section 2.1 (Task 1.8)
- Phase 1 Deliverable: Session CRUD API endpoints working
- Tests should verify full flow: HTTP → FastAPI → Service Layer → Repository → Database
- Uses pytest-asyncio for async test execution
- Test database should be isolated (in-memory or separate file)

## Input Files
- `IMPLEMENTATION_PLAN.md` - Task 1.8 description
- `src/api/routes/sessions.py` - From Spec 1.7
- `src/persistence/repositories/session_repo.py` - From Spec 1.6
- `src/domain/models/session.py` - From Spec 1.6

## Output Files

### Integration Tests
Create `tests/integration/test_sessions_api.py`:
```python
"""Integration tests for session API endpoints."""
import pytest
from httpx import AsyncClient
from src.main import app
from src.persistence.database import init_database, get_db_connection
from src.persistence.repositories.session_repo import SessionRepository
from src.domain.models.session import Session, SessionState
from datetime import datetime
import uuid
import aiosqlite
import os


@pytest.fixture(scope="module")
async def test_db():
    """Create isolated test database."""
    test_db_path = "test_interviews.db"

    # Initialize test database
    await init_database(test_db_path)

    yield test_db_path

    # Cleanup
    if os.path.exists(test_db_path):
        os.remove(test_db_path)


@pytest.fixture
async def client(test_db):
    """Create test client with test database."""
    # Override database dependency
    async def override_get_db():
        async with aiosqlite.connect(test_db) as db:
            yield db

    app.dependency_overrides[get_db_connection] = override_get_db

    async with AsyncClient(app=app, base_url="http://test") as ac:
        yield ac

    app.dependency_overrides.clear()


@pytest.fixture
async def session_repo(test_db):
    """Create session repository with test database."""
    return SessionRepository(test_db)


@pytest.mark.asyncio
async def test_create_session(client):
    """Test POST /sessions creates a new session."""
    response = await client.post(
        "/sessions/",
        json={
            "methodology": "mec",
            "concept_id": "test-concept",
            "concept_name": "Test Concept"
        }
    )

    assert response.status_code == 200
    data = response.json()
    assert "id" in data
    assert data["methodology"] == "mec"
    assert data["concept_id"] == "test-concept"
    assert data["concept_name"] == "Test Concept"
    assert data["status"] == "active"
    assert "created_at" in data
    assert "state" in data


@pytest.mark.asyncio
async def test_create_session_invalid_methodology(client):
    """Test POST /sessions with invalid methodology returns 422."""
    response = await client.post(
        "/sessions/",
        json={
            "methodology": "",  # Empty methodology
            "concept_id": "test-concept",
            "concept_name": "Test Concept"
        }
    )

    # Pydantic validation should catch this
    assert response.status_code == 422


@pytest.mark.asyncio
async def test_get_session(client, session_repo):
    """Test GET /sessions/{id} returns session."""
    # Create a session first via repository
    session = Session(
        id=str(uuid.uuid4()),
        methodology="mec",
        concept_id="test-concept",
        concept_name="Test Concept",
        created_at=datetime.utcnow(),
        updated_at=datetime.utcnow(),
        status="active",
        state=SessionState(
            methodology="mec",
            concept_id="test-concept",
            concept_name="Test Concept",
            turn_count=0,
            coverage_score=0.0
        )
    )
    await session_repo.create(session)

    # Get via API
    response = await client.get(f"/sessions/{session.id}")

    assert response.status_code == 200
    data = response.json()
    assert data["id"] == session.id
    assert data["methodology"] == "mec"
    assert data["concept_id"] == "test-concept"


@pytest.mark.asyncio
async def test_get_session_not_found(client):
    """Test GET /sessions/{id} with non-existent ID returns 404."""
    fake_id = str(uuid.uuid4())
    response = await client.get(f"/sessions/{fake_id}")

    assert response.status_code == 404
    assert "not found" in response.json()["detail"].lower()


@pytest.mark.asyncio
async def test_list_sessions(client, session_repo):
    """Test GET /sessions returns list of active sessions."""
    # Create multiple sessions
    for i in range(3):
        session = Session(
            id=str(uuid.uuid4()),
            methodology="mec",
            concept_id=f"concept-{i}",
            concept_name=f"Concept {i}",
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
            status="active",
            state=SessionState(
                methodology="mec",
                concept_id=f"concept-{i}",
                concept_name=f"Concept {i}",
                turn_count=0,
                coverage_score=0.0
            )
        )
        await session_repo.create(session)

    # List via API
    response = await client.get("/sessions/")

    assert response.status_code == 200
    data = response.json()
    assert isinstance(data, list)
    assert len(data) >= 3  # At least our 3 sessions


@pytest.mark.asyncio
async def test_delete_session(client, session_repo):
    """Test DELETE /sessions/{id} deletes session."""
    # Create a session first
    session = Session(
        id=str(uuid.uuid4()),
        methodology="mec",
        concept_id="test-concept",
        concept_name="Test Concept",
        created_at=datetime.utcnow(),
        updated_at=datetime.utcnow(),
        status="active",
        state=SessionState(
            methodology="mec",
            concept_id="test-concept",
            concept_name="Test Concept",
            turn_count=0,
            coverage_score=0.0
        )
    )
    await session_repo.create(session)

    # Delete via API
    response = await client.delete(f"/sessions/{session.id}")

    assert response.status_code == 204

    # Verify it's deleted
    get_response = await client.get(f"/sessions/{session.id}")
    assert get_response.status_code == 404


@pytest.mark.asyncio
async def test_delete_session_not_found(client):
    """Test DELETE /sessions/{id} with non-existent ID returns 404."""
    fake_id = str(uuid.uuid4())
    response = await client.delete(f"/sessions/{fake_id}")

    assert response.status_code == 404
    assert "not found" in response.json()["detail"].lower()


@pytest.mark.asyncio
async def test_session_flow(client):
    """Test complete session lifecycle: create → get → list → delete."""
    # Create
    create_response = await client.post(
        "/sessions/",
        json={
            "methodology": "mec",
            "concept_id": "flow-test",
            "concept_name": "Flow Test"
        }
    )
    assert create_response.status_code == 200
    session_id = create_response.json()["id"]

    # Get
    get_response = await client.get(f"/sessions/{session_id}")
    assert get_response.status_code == 200
    assert get_response.json()["id"] == session_id

    # List (should include our session)
    list_response = await client.get("/sessions/")
    assert list_response.status_code == 200
    session_ids = [s["id"] for s in list_response.json()]
    assert session_id in session_ids

    # Delete
    delete_response = await client.delete(f"/sessions/{session_id}")
    assert delete_response.status_code == 204

    # Verify gone
    verify_response = await client.get(f"/sessions/{session_id}")
    assert verify_response.status_code == 404
```

## Requirements

1. Tests use pytest-asyncio for async test execution
2. Test database is isolated (separate file from development database)
3. Tests verify full HTTP → Service → Repository → Database flow
4. Tests cover success paths and error cases (404, validation errors)
5. Fixtures properly set up and tear down test database
6. Tests are deterministic (no randomness, seeded data)

## Verification
```bash
# Check prerequisites
command -v python3 >/dev/null 2>&1 || pip3 install python3
python3 -c "import pytest" 2>/dev/null || pip3 install pytest pytest-asyncio httpx

# Run tests
pytest tests/integration/test_sessions_api.py -v
```

## Success Criteria
- [ ] Integration test file exists at `tests/integration/test_sessions_api.py`
- [ ] `test_create_session` creates session and returns valid response
- [ ] `test_get_session` retrieves created session
- [ ] `test_get_session_not_found` returns 404 for non-existent session
- [ ] `test_list_sessions` returns list of active sessions
- [ ] `test_delete_session` removes session from database
- [ ] `test_delete_session_not_found` returns 404 for non-existent session
- [ ] `test_session_flow` verifies complete lifecycle
- [ ] All tests pass with isolated test database
- [ ] Test database cleanup works (no lingering files)

## Dependencies
- Requires: SessionRepository from Spec 1.6
- Requires: Session API endpoints from Spec 1.7
- Requires: Database module from Spec 1.3
- Requires: FastAPI app from Spec 1.5
