# Spec 3.6: Richness Scorer

## Objective
Create the richness scorer to adapt to respondent engagement level.

## Context
- Reference: PRD Section 5.2.7 (Response quality), IMPLEMENTATION_PLAN.md Section 3.6
- v1 Reference: `/home/mikhailarutyunov/projects/graph-enabled-ai-interviewer/src/modules/scorers/response_richness_scorer.py`
- Simplifies v1: Removes MomentumLevel complexity, uses avg_response_length directly
- Penalizes depth on low engagement, boosts depth on high engagement

## Input Files
- `src/services/scoring/base.py` - From spec 3.1
- v1: `/home/mikhailarutyunov/projects/graph-enabled-ai-interviewer/src/modules/scorers/response_richness_scorer.py`

## Output Files

### src/services/scoring/richness.py
```python
"""Richness scorer - adapts to respondent engagement level.

Boosts depth when engagement is high, penalizes depth when engagement is low.
"""

from typing import Any, Dict, List

import structlog

from src.domain.models.knowledge_graph import GraphState
from src.services.scoring.base import ScorerBase, ScorerOutput


logger = structlog.get_logger(__name__)


class RichnessScorer(ScorerBase):
    """
    Adapt to respondent engagement level based on response length.

    Algorithm:
    1. Get avg_response_length from graph_state.properties
    2. Classify engagement: low (<50 chars), medium (50-200), high (>200)
    3. Low: penalize depth, boost breadth/coverage
    4. High: boost depth

    Scoring:
    - 1.0 = medium engagement (neutral)
    - low_engagement_penalty (e.g., 0.6) = low engagement, penalize depth
    - high_engagement_boost (e.g., 1.4) = high engagement, boost depth

    Configuration parameters:
    - low_threshold: Char count for low engagement (default: 50)
    - high_threshold: Char count for high engagement (default: 200)
    - low_engagement_penalty: Penalty for depth on low engagement (default: 0.6)
    - high_engagement_boost: Boost for depth on high engagement (default: 1.4)
    """

    def __init__(self, config: Dict[str, Any] = None):
        super().__init__(config)
        self.low_threshold = self.params.get("low_threshold", 50)
        self.high_threshold = self.params.get("high_threshold", 200)
        self.low_penalty = self.params.get("low_engagement_penalty", 0.6)
        self.high_boost = self.params.get("high_engagement_boost", 1.4)

    async def score(
        self,
        strategy: Dict[str, Any],
        focus: Dict[str, Any],
        graph_state: GraphState,
        recent_nodes: List[Dict[str, Any]],
    ) -> ScorerOutput:
        """
        Score based on response richness/engagement.

        Args:
            strategy: Strategy dict with 'type_category'
            focus: Focus dict (unused for richness scorer)
            graph_state: Graph state with avg_response_length in properties
            recent_nodes: Recent nodes (unused for richness scorer)

        Returns:
            ScorerOutput with engagement-based score
        """
        score = 1.0
        signals = {}
        reasons = []

        # Get average response length from graph_state
        avg_length = graph_state.properties.get("avg_response_length", 100)

        signals["avg_response_length"] = avg_length

        # Classify engagement level
        if avg_length < self.low_threshold:
            engagement = "low"
        elif avg_length < self.high_threshold:
            engagement = "medium"
        else:
            engagement = "high"

        signals["engagement_level"] = engagement

        # Apply scoring based on engagement level
        if engagement == "low":
            # Low engagement: penalize complex depth strategies
            if strategy.get("type_category") == "depth":
                score *= self.low_penalty
                reasons.append("Low engagement - depth penalized")
            # Boost simpler breadth/coverage
            elif strategy.get("type_category") in ["breadth", "coverage"]:
                boost = 1.0 / self.low_penalty
                score *= boost
                reasons.append("Low engagement - simpler strategies encouraged")

        elif engagement == "high":
            # High engagement: boost depth strategies
            if strategy.get("type_category") == "depth":
                score *= self.high_boost
                reasons.append("High engagement - depth encouraged")

        if not reasons:
            reasoning = f"Medium engagement (avg length={avg_length:.0f})"
        else:
            reasoning = "; ".join(reasons)

        logger.debug(
            "RichnessScorer output",
            strategy_id=strategy.get("id"),
            engagement=engagement,
            avg_length=avg_length,
            score=score,
        )

        return self.make_output(score, signals, reasoning)
```

## Requirements
1. Extends ScorerBase
2. Reads avg_response_length from graph_state.properties
3. Classifies engagement: low (<50), medium (50-200), high (>200)
4. Penalizes depth on low engagement
5. Boosts depth on high engagement
6. Configurable thresholds

## Verification
```bash
# Run tests
pytest tests/unit/test_richness_scorer.py -v

# Verify import
python3 -c "from src.services.scoring.richness import RichnessScorer; print('OK')"
```

## Success Criteria
- [ ] `RichnessScorer` class extends `ScorerBase`
- [ ] Classifies engagement from avg_response_length
- [ ] Penalizes depth when engagement is low
- [ ] Boosts breadth/coverage when engagement is low
- [ ] Boosts depth when engagement is high
- [ ] Returns 1.0 for medium engagement
- [ ] All tests pass
