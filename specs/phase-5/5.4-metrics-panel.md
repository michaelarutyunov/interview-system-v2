# Spec 5.4: Metrics Panel

## Objective
Create the metrics panel component for displaying interview statistics and diagnostics.

## Context
- Reference: v1 `src/ui/components/diagnostics_panel.py`
- Displays coverage, turn count, strategy selection
- Shows scoring breakdown
- Displays graph state information
- Streamlit metrics and visualizations

## Input Files
- Phase 3: `src/services/scoring/` - Scoring service
- v1: `/home/mikhailarutyunov/projects/graph-enabled-ai-interviewer/src/ui/components/diagnostics_panel.py`

## Output Files

### ui/components/metrics.py
```python
"""
Metrics panel component for Streamlit demo UI.

Displays interview statistics, scoring information, and diagnostics.
Uses Streamlit's metrics and visualization components.
"""

from typing import Dict, Any, Optional
import streamlit as st

import plotly.graph_objects as go


class MetricsPanel:
    """
    Displays interview metrics and diagnostics.
    
    Shows:
    - Coverage progress with visual bar
    - Turn count
    - Scoring breakdown
    - Strategy selection with reasoning
    - Graph statistics
    """
    
    def __init__(self):
        """Initialize metrics panel."""
        self.coverage_emoji = ["â¬œ", "ðŸŸ©"]  # Empty, Filled
    
    def render(self, status_data: Dict[str, Any], graph_data: Optional[Dict] = None):
        """
        Render the complete metrics panel.
        
        Args:
            status_data: Session status from /sessions/{id}/status
            graph_data: Optional graph data from /sessions/{id}/graph
        """
        st.subheader("ðŸ“Š Interview Metrics")
        
        # Main metrics row
        col1, col2, col3 = st.columns(3)
        
        with col1:
            self._render_turn_count(status_data)
        
        with col2:
            self._render_coverage(status_data)
        
        with col3:
            self._render_status(status_data)
        
        st.divider()
        
        # Scoring breakdown
        self._render_scoring(status_data)
        
        # Strategy info
        self._render_strategy(status_data)
        
        # Graph stats
        if graph_data:
            self._render_graph_stats(graph_data)
    
    def _render_turn_count(self, status_data: Dict[str, Any]):
        """Render turn count metric."""
        turn_number = status_data.get("turn_number", 0)
        max_turns = status_data.get("max_turns", 20)
        
        st.metric(
            label="Turns",
            value=f"{turn_number} / {max_turns}",
            delta=None,
        )
        
        # Progress bar
        if max_turns > 0:
            progress = turn_number / max_turns
            st.progress(progress)
    
    def _render_coverage(self, status_data: Dict[str, Any]):
        """Render coverage metric with visual bar."""
        coverage = status_data.get("coverage", 0.0)
        target = status_data.get("target_coverage", 0.8)
        
        # Determine color based on achievement
        if coverage >= target:
            delta_color = "normal"
        else:
            delta_color = "inverse"
        
        st.metric(
            label="Coverage",
            value=f"{coverage*100:.1f}%",
            delta=f"Target: {target*100:.0f}%",
            delta_color=delta_color,
        )
        
        # Visual coverage bar (10 segments)
        filled = int(coverage * 10)
        bar = "".join([self.coverage_emoji[1]] * filled + [self.coverage_emoji[0]] * (10 - filled))
        st.markdown(f"<p style='font-size: 24px; letter-spacing: 2px;'>{bar}</p>", unsafe_allow_html=True)
    
    def _render_status(self, status_data: Dict[str, Any]):
        """Render session status."""
        session_status = status_data.get("status", "unknown")
        should_continue = status_data.get("should_continue", True)
        
        # Status indicator
        status_emoji = {
            "active": "ðŸ”„",
            "completed": "âœ…",
            "coverage_met": "ðŸŽ¯",
            "max_turns_reached": "ðŸ“Š",
            "saturated": "ðŸ”’",
        }.get(session_status, "â“")
        
        st.metric(
            label="Status",
            value=f"{status_emoji} {session_status.replace('_', ' ').title()}",
        )
        
        if not should_continue and session_status == "active":
            st.caption("Interview should end soon")
    
    def _render_scoring(self, status_data: Dict[str, Any]):
        """Render scoring breakdown."""
        scoring = status_data.get("scoring", {})
        
        if not scoring:
            st.info("No scoring data available yet.")
            return
        
        st.write("**Scoring Breakdown:**")
        
        # Create metrics for each score
        scores = {
            "Coverage": scoring.get("coverage", 0.0),
            "Depth": scoring.get("depth", 0.0),
            "Saturation": scoring.get("saturation", 0.0),
            "Novelty": scoring.get("novelty", 0.0),
            "Richness": scoring.get("richness", 0.0),
        }
        
        # Render as gauge charts
        cols = st.columns(len(scores))
        for i, (name, value) in enumerate(scores.items()):
            with cols[i]:
                self._render_gauge(name, value)
    
    def _render_gauge(self, name: str, value: float):
        """Render a gauge chart for a score."""
        fig = go.Figure(go.Indicator(
            mode = "gauge+number",
            value = value,
            domain = {'x': [0, 1], 'y': [0, 1]},
            title = {'text': name},
            gauge = {
                'axis': {'range': [0, 1]},
                'bar': {'color': "darkblue"},
                'steps': [
                    {'range': [0, 0.5], 'color': "lightgray"},
                    {'range': [0.5, 0.8], 'color': "gray"},
                ],
                'threshold': {
                    'line': {'color': "red", 'width': 4},
                    'thickness': 0.75,
                    'value': 0.9
                }
            }
        ))
        
        fig.update_layout(
            height=200,
            margin=dict(l=10, r=10, t=30, b=10),
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    def _render_strategy(self, status_data: Dict[str, Any]):
        """Render strategy selection info."""
        strategy = status_data.get("strategy_selected", "unknown")
        reasoning = status_data.get("strategy_reasoning", "")
        
        st.write("**Current Strategy:**")
        
        strategy_descriptions = {
            "deepen": "ðŸ” Deepen - Explore deeper in current topic chain",
            "broaden": "ðŸŒ Broaden - Find new topic branches",
            "cover": "ðŸŽ¯ Cover - Introduce unexplored elements",
            "close": "âœ… Close - Wrap up the interview",
        }
        
        st.info(strategy_descriptions.get(strategy, f"Strategy: {strategy}"))
        
        if reasoning:
            with st.expander("See strategy reasoning"):
                st.write(reasoning)
    
    def _render_graph_stats(self, graph_data: Dict[str, Any]):
        """Render graph statistics."""
        nodes = graph_data.get("nodes", [])
        edges = graph_data.get("edges", [])
        
        st.write("**Knowledge Graph:**")
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Nodes", len(nodes))
        with col2:
            st.metric("Edges", len(edges))
        
        # Node type distribution
        if nodes:
            node_types = {}
            for node in nodes:
                node_type = node.get("node_type", "unknown")
                node_types[node_type] = node_types.get(node_type, 0) + 1
            
            if node_types:
                st.write("**Node Types:**")
                fig = go.Figure(data=[
                    go.Pie(
                        labels=list(node_types.keys()),
                        values=list(node_types.values()),
                        hole=0.3,
                    )
                ])
                fig.update_layout(
                    height=250,
                    margin=dict(l=10, r=10, t=10, b=10),
                )
                st.plotly_chart(fig, use_container_width=True)


def render_turn_diagnostics(turn_result: Dict[str, Any]):
    """
    Render diagnostics for a single turn.
    
    Args:
        turn_result: Turn result from submit_turn API call
    """
    with st.expander("ðŸ” Turn Diagnostics"):
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("**Extraction:**")
            extracted = turn_result.get("extracted", {})
            st.write(f"- Concepts: {len(extracted.get('concepts', []))}")
            st.write(f"- Relationships: {len(extracted.get('relationships', []))}")
        
        with col2:
            st.write("**Timing:**")
            latency = turn_result.get("latency_ms", 0)
            st.write(f"- Latency: {latency:.0f}ms")
        
        # Show extracted concepts
        extracted = turn_result.get("extracted", {})
        concepts = extracted.get("concepts", [])
        if concepts:
            st.write("**Extracted Concepts:**")
            for concept in concepts[:5]:  # Show first 5
                st.write(f"- {concept.get('text', 'N/A')} ({concept.get('node_type', 'N/A')})")
            
            if len(concepts) > 5:
                st.caption(f"... and {len(concepts) - 5} more")


def render_coverage_details(coverage_data: Dict[str, Any]):
    """
    Render detailed coverage information.
    
    Args:
        coverage_data: Coverage data from API
    """
    with st.expander("ðŸ“‹ Coverage Details"):
        elements = coverage_data.get("elements", [])
        
        if not elements:
            st.info("No element coverage data available.")
            return
        
        # Group by status
        covered = [e for e in elements if e.get("covered", False)]
        uncovered = [e for e in elements if not e.get("covered", False)]
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.metric("Covered", len(covered))
            if covered:
                for elem in covered[:5]:
                    st.write(f"âœ… {elem.get('label', 'N/A')}")
        
        with col2:
            st.metric "Remaining", len(uncovered))
            if uncovered:
                for elem in uncovered[:5]:
                    st.write(f"â¬œ {elem.get('label', 'N/A')}")
```

## Requirements
1. Display turn count with progress bar
2. Display coverage with visual indicator
3. Display session status with emoji
4. Show scoring breakdown with gauge charts
5. Show strategy selection with description
6. Display graph statistics
7. Show turn diagnostics in expandable section
8. Display coverage details

## Verification
```bash
# Verify imports
python3 -c "
from ui.components.metrics import MetricsPanel, render_turn_diagnostics, render_coverage_details
print('Metrics components imported')
"

# Verify Plotly gauge functionality
python3 -c "
import plotly.graph_objects as go
fig = go.Figure(go.Indicator(mode='gauge+number', value=0.5))
print('Gauge chart works')
"
```

## Success Criteria
- [ ] `ui/components/metrics.py` created with MetricsPanel class
- [ ] `render()` - displays complete metrics panel
- [ ] `_render_turn_count()` - turn count with progress bar
- [ ] `_render_coverage()` - coverage with visual bar
- [ ] `_render_scoring()` - gauge charts for scores
- [ ] `_render_strategy()` - strategy with description
- [ ] `_render_graph_stats()` - node/edge counts and pie chart
- [ ] `render_turn_diagnostics()` - turn-level details
- [ ] `render_coverage_details()` - element coverage breakdown
- [ ] Components import without errors
