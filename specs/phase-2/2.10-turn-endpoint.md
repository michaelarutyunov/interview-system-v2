# Spec 2.10: Turn Endpoint

## Objective
Create the API endpoint for processing interview turns.

## Context
- Reference: PRD Section 8.1 (`POST /sessions/{id}/turns`)
- Integrates SessionService from spec 2.9
- Returns TurnResult as JSON response
- FastAPI route with proper error handling

## Input Files
- `src/services/session_service.py` - Session service from spec 2.9
- `PRD.md` - Section 8.1, 8.6 (API spec, response structure)
- `src/api/routes/sessions.py` - Existing session routes from Phase 1

## Output Files

### src/api/schemas.py (update)
```python
"""
API request/response schemas.

Pydantic models for API validation and serialization.
"""

from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional
from datetime import datetime


# ============ SESSION SCHEMAS (from Phase 1) ============

class SessionCreate(BaseModel):
    """Request to create a new session."""
    methodology: str = Field(default="means_end_chain")
    concept_id: str
    config: Dict[str, Any] = Field(default_factory=dict)


class SessionResponse(BaseModel):
    """Session details response."""
    id: str
    methodology: str
    concept_id: str
    status: str
    config: Dict[str, Any]
    turn_count: int = 0
    created_at: datetime
    updated_at: datetime


class SessionListResponse(BaseModel):
    """List of sessions response."""
    sessions: List[SessionResponse]
    total: int


# ============ TURN SCHEMAS (Phase 2) ============

class TurnRequest(BaseModel):
    """Request to process a turn."""
    text: str = Field(
        ...,
        min_length=1,
        max_length=5000,
        description="User's response text"
    )


class ExtractedConceptSchema(BaseModel):
    """Extracted concept in response."""
    text: str
    type: str
    confidence: float


class ExtractedRelationshipSchema(BaseModel):
    """Extracted relationship in response."""
    source: str
    target: str
    type: str


class ExtractionSchema(BaseModel):
    """Extraction results in turn response."""
    concepts: List[ExtractedConceptSchema] = Field(default_factory=list)
    relationships: List[ExtractedRelationshipSchema] = Field(default_factory=list)


class GraphStateSchema(BaseModel):
    """Graph state in turn response."""
    node_count: int
    edge_count: int
    depth_achieved: Dict[str, int] = Field(default_factory=dict)


class ScoringSchema(BaseModel):
    """Scoring results in turn response (Phase 3)."""
    coverage: float = 0.0
    depth: float = 0.0
    saturation: float = 0.0


class TurnResponse(BaseModel):
    """Response from processing a turn.

    Matches PRD Section 8.6.
    """
    turn_number: int
    extracted: ExtractionSchema
    graph_state: GraphStateSchema
    scoring: ScoringSchema
    strategy_selected: str
    next_question: str
    should_continue: bool
    latency_ms: int = 0

    class Config:
        json_schema_extra = {
            "example": {
                "turn_number": 3,
                "extracted": {
                    "concepts": [
                        {"text": "creamy texture", "type": "attribute", "confidence": 0.9}
                    ],
                    "relationships": [
                        {"source": "creamy texture", "target": "satisfying", "type": "leads_to"}
                    ]
                },
                "graph_state": {
                    "node_count": 5,
                    "edge_count": 3,
                    "depth_achieved": {"attribute": 3, "functional_consequence": 2}
                },
                "scoring": {
                    "coverage": 0.25,
                    "depth": 0.15,
                    "saturation": 0.0
                },
                "strategy_selected": "deepen",
                "next_question": "You mentioned the creamy texture feels satisfying. Why is that feeling important to you?",
                "should_continue": True,
                "latency_ms": 1250
            }
        }


class StartSessionResponse(BaseModel):
    """Response from starting a session."""
    session_id: str
    opening_question: str


class ErrorResponse(BaseModel):
    """Error response schema."""
    detail: str
    error_type: Optional[str] = None
```

### src/api/routes/sessions.py (update)
```python
"""
Session API routes.

Endpoints for session management and turn processing.
"""

from fastapi import APIRouter, Depends, HTTPException, status
import aiosqlite
import structlog

from src.api.schemas import (
    SessionCreate,
    SessionResponse,
    SessionListResponse,
    TurnRequest,
    TurnResponse,
    StartSessionResponse,
    ExtractionSchema,
    GraphStateSchema,
    ScoringSchema,
    ExtractedConceptSchema,
    ExtractedRelationshipSchema,
)
from src.persistence.database import get_db
from src.persistence.repositories.session_repo import SessionRepository
from src.persistence.repositories.graph_repo import GraphRepository
from src.services.session_service import SessionService
from src.core.exceptions import SessionNotFoundError, SessionCompletedError

log = structlog.get_logger(__name__)

router = APIRouter(prefix="/sessions", tags=["sessions"])


# ============ DEPENDENCY INJECTION ============

async def get_session_service(
    db: aiosqlite.Connection = Depends(get_db),
) -> SessionService:
    """
    Create SessionService with dependencies.

    Injected into route handlers.
    """
    session_repo = SessionRepository(db)
    graph_repo = GraphRepository(db)

    return SessionService(
        session_repo=session_repo,
        graph_repo=graph_repo,
    )


# ============ SESSION CRUD (from Phase 1) ============

@router.post(
    "",
    response_model=SessionResponse,
    status_code=status.HTTP_201_CREATED,
)
async def create_session(
    request: SessionCreate,
    db: aiosqlite.Connection = Depends(get_db),
):
    """Create a new interview session."""
    repo = SessionRepository(db)
    session = await repo.create(
        methodology=request.methodology,
        concept_id=request.concept_id,
        config=request.config,
    )

    return SessionResponse(
        id=session.id,
        methodology=session.methodology,
        concept_id=session.concept_id,
        status=session.status,
        config=session.config,
        turn_count=session.turn_count or 0,
        created_at=session.created_at,
        updated_at=session.updated_at,
    )


@router.get("", response_model=SessionListResponse)
async def list_sessions(
    db: aiosqlite.Connection = Depends(get_db),
    status_filter: str = None,
):
    """List all sessions, optionally filtered by status."""
    repo = SessionRepository(db)
    sessions = await repo.list(status=status_filter)

    return SessionListResponse(
        sessions=[
            SessionResponse(
                id=s.id,
                methodology=s.methodology,
                concept_id=s.concept_id,
                status=s.status,
                config=s.config,
                turn_count=s.turn_count or 0,
                created_at=s.created_at,
                updated_at=s.updated_at,
            )
            for s in sessions
        ],
        total=len(sessions),
    )


@router.get("/{session_id}", response_model=SessionResponse)
async def get_session(
    session_id: str,
    db: aiosqlite.Connection = Depends(get_db),
):
    """Get session details by ID."""
    repo = SessionRepository(db)
    session = await repo.get(session_id)

    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Session {session_id} not found",
        )

    return SessionResponse(
        id=session.id,
        methodology=session.methodology,
        concept_id=session.concept_id,
        status=session.status,
        config=session.config,
        turn_count=session.turn_count or 0,
        created_at=session.created_at,
        updated_at=session.updated_at,
    )


@router.delete("/{session_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_session(
    session_id: str,
    db: aiosqlite.Connection = Depends(get_db),
):
    """Delete/close a session."""
    repo = SessionRepository(db)
    success = await repo.delete(session_id)

    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Session {session_id} not found",
        )


# ============ TURN PROCESSING (Phase 2) ============

@router.post(
    "/{session_id}/start",
    response_model=StartSessionResponse,
)
async def start_session(
    session_id: str,
    service: SessionService = Depends(get_session_service),
):
    """
    Start an interview session and get the opening question.

    Must be called before process_turn.
    """
    log.info("starting_session", session_id=session_id)

    try:
        opening_question = await service.start_session(session_id)

        return StartSessionResponse(
            session_id=session_id,
            opening_question=opening_question,
        )

    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )
    except Exception as e:
        log.error("start_session_failed", session_id=session_id, error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to start session: {e}",
        )


@router.post(
    "/{session_id}/turns",
    response_model=TurnResponse,
)
async def process_turn(
    session_id: str,
    request: TurnRequest,
    service: SessionService = Depends(get_session_service),
):
    """
    Process a respondent turn.

    Takes user input text, extracts concepts, updates graph,
    and returns next question.
    """
    log.info(
        "processing_turn_request",
        session_id=session_id,
        text_length=len(request.text),
    )

    try:
        result = await service.process_turn(
            session_id=session_id,
            user_input=request.text,
        )

        # Convert to response schema
        return TurnResponse(
            turn_number=result.turn_number,
            extracted=ExtractionSchema(
                concepts=[
                    ExtractedConceptSchema(**c) for c in result.extracted["concepts"]
                ],
                relationships=[
                    ExtractedRelationshipSchema(**r) for r in result.extracted["relationships"]
                ],
            ),
            graph_state=GraphStateSchema(
                node_count=result.graph_state["node_count"],
                edge_count=result.graph_state["edge_count"],
                depth_achieved=result.graph_state.get("depth_achieved", {}),
            ),
            scoring=ScoringSchema(
                coverage=result.scoring["coverage"],
                depth=result.scoring["depth"],
                saturation=result.scoring["saturation"],
            ),
            strategy_selected=result.strategy_selected,
            next_question=result.next_question,
            should_continue=result.should_continue,
            latency_ms=result.latency_ms,
        )

    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )
    except SessionCompletedError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Session has already completed",
        )
    except Exception as e:
        log.error(
            "process_turn_failed",
            session_id=session_id,
            error=str(e),
            error_type=type(e).__name__,
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Turn processing failed: {e}",
        )
```

### tests/integration/test_turn_api.py
```python
"""Integration tests for turn processing API."""

import pytest
from httpx import AsyncClient, ASGITransport
from unittest.mock import AsyncMock, patch
import tempfile
from pathlib import Path

from src.main import app
from src.persistence.database import init_database


@pytest.fixture
async def test_db():
    """Create test database."""
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = Path(tmpdir) / "test.db"
        await init_database(db_path)

        # Patch settings to use test db
        with patch("src.core.config.settings") as mock_settings:
            mock_settings.database_path = db_path
            mock_settings.anthropic_api_key = "test-key"
            mock_settings.llm_model = "claude-sonnet-4-20250514"
            mock_settings.llm_timeout_seconds = 30.0
            mock_settings.llm_temperature = 0.7
            mock_settings.llm_max_tokens = 1024
            mock_settings.llm_provider = "anthropic"
            yield db_path


@pytest.fixture
async def client(test_db):
    """Create test client."""
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac


@pytest.fixture
async def session_id(client):
    """Create a test session."""
    response = await client.post(
        "/sessions",
        json={
            "concept_id": "test-concept",
            "config": {"concept_name": "Test Product"},
        },
    )
    return response.json()["id"]


class TestProcessTurnEndpoint:
    """Tests for POST /sessions/{id}/turns."""

    @pytest.mark.asyncio
    async def test_process_turn_returns_200(self, client, session_id):
        """Returns 200 with turn result."""
        # Mock LLM calls
        with patch("src.services.extraction_service.ExtractionService.extract") as mock_extract:
            with patch("src.services.question_service.QuestionService.generate_question") as mock_question:
                mock_extract.return_value = AsyncMock(
                    concepts=[],
                    relationships=[],
                    is_extractable=True,
                    discourse_markers=[],
                    latency_ms=100,
                )()
                mock_question.return_value = "Why is that important?"

                response = await client.post(
                    f"/sessions/{session_id}/turns",
                    json={"text": "I like the taste"},
                )

        assert response.status_code == 200
        data = response.json()
        assert "turn_number" in data
        assert "next_question" in data
        assert "should_continue" in data

    @pytest.mark.asyncio
    async def test_process_turn_404_for_unknown_session(self, client):
        """Returns 404 for unknown session."""
        response = await client.post(
            "/sessions/nonexistent/turns",
            json={"text": "Hello"},
        )

        assert response.status_code == 404

    @pytest.mark.asyncio
    async def test_process_turn_validates_text(self, client, session_id):
        """Validates text is not empty."""
        response = await client.post(
            f"/sessions/{session_id}/turns",
            json={"text": ""},
        )

        assert response.status_code == 422  # Validation error


class TestStartSessionEndpoint:
    """Tests for POST /sessions/{id}/start."""

    @pytest.mark.asyncio
    async def test_start_session_returns_question(self, client, session_id):
        """Returns opening question."""
        with patch("src.services.question_service.QuestionService.generate_opening_question") as mock:
            mock.return_value = "What do you think about Test Product?"

            response = await client.post(f"/sessions/{session_id}/start")

        assert response.status_code == 200
        data = response.json()
        assert data["session_id"] == session_id
        assert "opening_question" in data

    @pytest.mark.asyncio
    async def test_start_session_404_for_unknown(self, client):
        """Returns 404 for unknown session."""
        response = await client.post("/sessions/unknown/start")

        assert response.status_code == 404
```

## Requirements
1. `POST /sessions/{id}/turns` endpoint per PRD Section 8.1
2. Request validation (text required, max 5000 chars)
3. Response matches PRD Section 8.6 structure
4. Proper HTTP status codes (200, 404, 422, 500)
5. Error handling with structured responses
6. Logging of all requests
7. `POST /sessions/{id}/start` for opening question

## Verification
```bash
# Run API tests
pytest tests/integration/test_turn_api.py -v

# Manual test with curl (after starting server)
# Start: uvicorn src.main:app --reload

# Create session
curl -X POST http://localhost:8000/sessions \
  -H "Content-Type: application/json" \
  -d '{"concept_id": "oat-milk", "config": {"concept_name": "Oat Milk"}}'

# Start session
curl -X POST http://localhost:8000/sessions/{session_id}/start

# Process turn
curl -X POST http://localhost:8000/sessions/{session_id}/turns \
  -H "Content-Type: application/json" \
  -d '{"text": "I love the creamy texture"}'
```

## Success Criteria
- [ ] `TurnRequest` schema with text validation
- [ ] `TurnResponse` schema matching PRD Section 8.6
- [ ] `POST /sessions/{id}/turns` endpoint implemented
- [ ] `POST /sessions/{id}/start` endpoint for opening question
- [ ] 404 returned for unknown session
- [ ] 422 returned for validation errors
- [ ] 500 returned with error details on failure
- [ ] All requests logged with structlog
- [ ] All integration tests pass
