# Spec 2.6: Graph Service

## Objective
Create the graph service that provides business logic for knowledge graph operations, including deduplication and extraction integration.

## Context
- Reference: PRD Section 4.1 (step 3: "Updates knowledge graph")
- v1 Reference: `src/modules/knowledge_graph_manager.py`
- Service layer wraps repository with business logic
- Key function: Convert extraction results to graph nodes/edges with deduplication

## Input Files
- `src/persistence/repositories/graph_repo.py` - Repository from spec 2.5
- `src/domain/models/extraction.py` - Extraction models from spec 2.1
- `src/domain/models/knowledge_graph.py` - Graph models from spec 2.1
- v1: `/home/mikhailarutyunov/projects/graph-enabled-ai-interviewer/src/modules/knowledge_graph_manager.py`

## Output Files

### src/services/graph_service.py
```python
"""
Graph service for knowledge graph business logic.

Responsibilities:
- Convert extraction results to graph nodes/edges
- Deduplicate nodes by label match
- Link nodes to source utterances (provenance)
- Compute graph state for scoring

Uses GraphRepository for persistence.
"""

from typing import List, Optional, Tuple

import structlog

from src.domain.models.extraction import (
    ExtractedConcept,
    ExtractedRelationship,
    ExtractionResult,
)
from src.domain.models.knowledge_graph import KGNode, KGEdge, GraphState
from src.persistence.repositories.graph_repo import GraphRepository

log = structlog.get_logger(__name__)


class GraphService:
    """
    Service for knowledge graph operations.

    Provides business logic layer over GraphRepository:
    - Deduplication when adding nodes
    - Extraction result integration
    - Graph state computation
    """

    def __init__(self, repo: GraphRepository):
        """
        Initialize graph service.

        Args:
            repo: GraphRepository instance
        """
        self.repo = repo

    async def add_extraction_to_graph(
        self,
        session_id: str,
        extraction: ExtractionResult,
        utterance_id: str,
    ) -> Tuple[List[KGNode], List[KGEdge]]:
        """
        Add extraction results to the knowledge graph.

        Pipeline:
        1. For each concept: deduplicate or create node
        2. Link nodes to source utterance
        3. For each relationship: create edge between nodes

        Args:
            session_id: Session ID
            extraction: Extraction result from ExtractionService
            utterance_id: Source utterance ID for provenance

        Returns:
            (added_nodes, added_edges) tuple
        """
        if not extraction.is_extractable:
            log.debug("extraction_not_extractable", session_id=session_id)
            return [], []

        log.info(
            "adding_extraction_to_graph",
            session_id=session_id,
            concept_count=len(extraction.concepts),
            relationship_count=len(extraction.relationships),
        )

        # Step 1: Process concepts into nodes
        label_to_node = {}  # Map concept text to node for edge creation
        added_nodes = []

        for concept in extraction.concepts:
            node = await self._add_or_get_node(
                session_id=session_id,
                concept=concept,
                utterance_id=utterance_id,
            )
            if node:
                label_to_node[concept.text.lower()] = node
                added_nodes.append(node)

        # Step 2: Process relationships into edges
        added_edges = []

        for relationship in extraction.relationships:
            edge = await self._add_edge_from_relationship(
                session_id=session_id,
                relationship=relationship,
                label_to_node=label_to_node,
                utterance_id=utterance_id,
            )
            if edge:
                added_edges.append(edge)

        log.info(
            "extraction_added_to_graph",
            session_id=session_id,
            nodes_added=len(added_nodes),
            edges_added=len(added_edges),
        )

        return added_nodes, added_edges

    async def _add_or_get_node(
        self,
        session_id: str,
        concept: ExtractedConcept,
        utterance_id: str,
    ) -> Optional[KGNode]:
        """
        Add a concept as node, or get existing node if duplicate.

        Deduplication strategy (v2 simplified):
        1. Exact label match (case-insensitive)
        2. If match found, add utterance to provenance
        3. If no match, create new node

        Args:
            session_id: Session ID
            concept: Extracted concept
            utterance_id: Source utterance ID

        Returns:
            KGNode (existing or newly created)
        """
        # Try to find existing node
        existing = await self.repo.find_node_by_label(session_id, concept.text)

        if existing:
            log.debug(
                "node_deduplicated",
                label=concept.text,
                existing_id=existing.id,
            )
            # Add this utterance to provenance
            return await self.repo.add_source_utterance(existing.id, utterance_id)

        # Create new node
        return await self.repo.create_node(
            session_id=session_id,
            label=concept.text,
            node_type=concept.node_type,
            confidence=concept.confidence,
            properties=concept.properties,
            source_utterance_ids=[utterance_id],
        )

    async def _add_edge_from_relationship(
        self,
        session_id: str,
        relationship: ExtractedRelationship,
        label_to_node: dict,
        utterance_id: str,
    ) -> Optional[KGEdge]:
        """
        Create edge from extracted relationship.

        Args:
            session_id: Session ID
            relationship: Extracted relationship
            label_to_node: Map of concept text to node
            utterance_id: Source utterance ID

        Returns:
            KGEdge or None if nodes not found
        """
        # Find source and target nodes
        source_node = label_to_node.get(relationship.source_text.lower())
        target_node = label_to_node.get(relationship.target_text.lower())

        if not source_node or not target_node:
            log.warning(
                "edge_skipped_missing_node",
                source=relationship.source_text,
                target=relationship.target_text,
                source_found=source_node is not None,
                target_found=target_node is not None,
            )
            return None

        # Check for existing edge (deduplication)
        existing = await self.repo.find_edge(
            session_id=session_id,
            source_node_id=source_node.id,
            target_node_id=target_node.id,
            edge_type=relationship.relationship_type,
        )

        if existing:
            log.debug(
                "edge_deduplicated",
                source=source_node.label,
                target=target_node.label,
            )
            # Add this utterance to provenance
            return await self.repo.add_edge_source_utterance(existing.id, utterance_id)

        # Create new edge
        return await self.repo.create_edge(
            session_id=session_id,
            source_node_id=source_node.id,
            target_node_id=target_node.id,
            edge_type=relationship.relationship_type,
            confidence=relationship.confidence,
            source_utterance_ids=[utterance_id],
        )

    async def get_session_graph(
        self, session_id: str
    ) -> Tuple[List[KGNode], List[KGEdge]]:
        """
        Get complete graph for a session.

        Args:
            session_id: Session ID

        Returns:
            (nodes, edges) tuple
        """
        nodes = await self.repo.get_nodes_by_session(session_id)
        edges = await self.repo.get_edges_by_session(session_id)

        return nodes, edges

    async def get_graph_state(self, session_id: str) -> GraphState:
        """
        Get graph state for scoring.

        Args:
            session_id: Session ID

        Returns:
            GraphState with counts and metrics
        """
        return await self.repo.get_graph_state(session_id)

    async def get_node(self, node_id: str) -> Optional[KGNode]:
        """
        Get a single node by ID.

        Args:
            node_id: Node ID

        Returns:
            KGNode or None
        """
        return await self.repo.get_node(node_id)

    async def get_nodes_of_type(
        self, session_id: str, node_type: str
    ) -> List[KGNode]:
        """
        Get all nodes of a specific type.

        Args:
            session_id: Session ID
            node_type: Node type to filter

        Returns:
            List of nodes matching type
        """
        all_nodes = await self.repo.get_nodes_by_session(session_id)
        return [n for n in all_nodes if n.node_type == node_type]

    async def get_recent_nodes(
        self, session_id: str, limit: int = 5
    ) -> List[KGNode]:
        """
        Get most recently added nodes.

        Args:
            session_id: Session ID
            limit: Maximum nodes to return

        Returns:
            List of nodes sorted by recorded_at descending
        """
        nodes = await self.repo.get_nodes_by_session(session_id)
        sorted_nodes = sorted(nodes, key=lambda n: n.recorded_at, reverse=True)
        return sorted_nodes[:limit]

    async def handle_contradiction(
        self,
        session_id: str,
        old_node_id: str,
        new_concept: ExtractedConcept,
        utterance_id: str,
    ) -> Tuple[KGNode, KGEdge]:
        """
        Handle a contradiction between old and new beliefs.

        Creates new node and REVISES edge, marks old node as superseded.

        Args:
            session_id: Session ID
            old_node_id: ID of node being contradicted
            new_concept: New contradicting concept
            utterance_id: Source utterance ID

        Returns:
            (new_node, revises_edge) tuple
        """
        # Create new node for the new belief
        new_node = await self.repo.create_node(
            session_id=session_id,
            label=new_concept.text,
            node_type=new_concept.node_type,
            confidence=new_concept.confidence,
            source_utterance_ids=[utterance_id],
        )

        # Mark old node as superseded
        await self.repo.supersede_node(old_node_id, new_node.id)

        # Create REVISES edge
        edge = await self.repo.create_edge(
            session_id=session_id,
            source_node_id=new_node.id,
            target_node_id=old_node_id,
            edge_type="revises",
            confidence=new_concept.confidence,
            source_utterance_ids=[utterance_id],
        )

        log.info(
            "contradiction_handled",
            old_node_id=old_node_id,
            new_node_id=new_node.id,
        )

        return new_node, edge
```

### tests/unit/test_graph_service.py
```python
"""Tests for graph service."""

import pytest
from unittest.mock import AsyncMock, MagicMock

from src.services.graph_service import GraphService
from src.domain.models.extraction import (
    ExtractedConcept,
    ExtractedRelationship,
    ExtractionResult,
)
from src.domain.models.knowledge_graph import KGNode, KGEdge, GraphState


@pytest.fixture
def mock_repo():
    """Create mock graph repository."""
    repo = AsyncMock()
    return repo


@pytest.fixture
def service(mock_repo):
    """Create graph service with mock repo."""
    return GraphService(mock_repo)


@pytest.fixture
def sample_extraction():
    """Create sample extraction result."""
    return ExtractionResult(
        concepts=[
            ExtractedConcept(
                text="creamy texture",
                node_type="attribute",
                confidence=0.9,
            ),
            ExtractedConcept(
                text="satisfying",
                node_type="functional_consequence",
                confidence=0.8,
            ),
        ],
        relationships=[
            ExtractedRelationship(
                source_text="creamy texture",
                target_text="satisfying",
                relationship_type="leads_to",
                confidence=0.75,
            ),
        ],
        is_extractable=True,
    )


class TestAddExtractionToGraph:
    """Tests for add_extraction_to_graph."""

    @pytest.mark.asyncio
    async def test_adds_nodes_and_edges(self, service, mock_repo, sample_extraction):
        """Adds nodes and edges from extraction."""
        # Setup: repo returns created nodes
        mock_repo.find_node_by_label.return_value = None  # No duplicates
        mock_repo.find_edge.return_value = None  # No duplicate edges

        node1 = KGNode(
            id="n1", session_id="s1", label="creamy texture",
            node_type="attribute", source_utterance_ids=["u1"]
        )
        node2 = KGNode(
            id="n2", session_id="s1", label="satisfying",
            node_type="functional_consequence", source_utterance_ids=["u1"]
        )
        edge = KGEdge(
            id="e1", session_id="s1", source_node_id="n1",
            target_node_id="n2", edge_type="leads_to", source_utterance_ids=["u1"]
        )

        mock_repo.create_node.side_effect = [node1, node2]
        mock_repo.create_edge.return_value = edge

        nodes, edges = await service.add_extraction_to_graph(
            session_id="s1",
            extraction=sample_extraction,
            utterance_id="u1",
        )

        assert len(nodes) == 2
        assert len(edges) == 1
        assert mock_repo.create_node.call_count == 2
        assert mock_repo.create_edge.call_count == 1

    @pytest.mark.asyncio
    async def test_deduplicates_nodes(self, service, mock_repo, sample_extraction):
        """Deduplicates nodes by label."""
        # Setup: first concept already exists
        existing_node = KGNode(
            id="existing", session_id="s1", label="creamy texture",
            node_type="attribute", source_utterance_ids=["old-u"]
        )
        mock_repo.find_node_by_label.side_effect = [
            existing_node,  # First concept exists
            None,  # Second concept doesn't exist
        ]
        mock_repo.add_source_utterance.return_value = existing_node
        mock_repo.create_node.return_value = KGNode(
            id="new", session_id="s1", label="satisfying",
            node_type="functional_consequence", source_utterance_ids=["u1"]
        )
        mock_repo.find_edge.return_value = None
        mock_repo.create_edge.return_value = KGEdge(
            id="e1", session_id="s1", source_node_id="existing",
            target_node_id="new", edge_type="leads_to", source_utterance_ids=["u1"]
        )

        nodes, edges = await service.add_extraction_to_graph(
            session_id="s1",
            extraction=sample_extraction,
            utterance_id="u1",
        )

        # Should have called add_source_utterance for existing node
        mock_repo.add_source_utterance.assert_called_once()
        # Should only create one new node
        assert mock_repo.create_node.call_count == 1

    @pytest.mark.asyncio
    async def test_skips_non_extractable(self, service, mock_repo):
        """Skips non-extractable results."""
        extraction = ExtractionResult(is_extractable=False)

        nodes, edges = await service.add_extraction_to_graph(
            session_id="s1",
            extraction=extraction,
            utterance_id="u1",
        )

        assert nodes == []
        assert edges == []
        mock_repo.create_node.assert_not_called()


class TestGetSessionGraph:
    """Tests for get_session_graph."""

    @pytest.mark.asyncio
    async def test_returns_nodes_and_edges(self, service, mock_repo):
        """Returns all nodes and edges for session."""
        mock_repo.get_nodes_by_session.return_value = [
            KGNode(id="n1", session_id="s1", label="a", node_type="attribute")
        ]
        mock_repo.get_edges_by_session.return_value = []

        nodes, edges = await service.get_session_graph("s1")

        assert len(nodes) == 1
        mock_repo.get_nodes_by_session.assert_called_with("s1")


class TestGetGraphState:
    """Tests for get_graph_state."""

    @pytest.mark.asyncio
    async def test_delegates_to_repo(self, service, mock_repo):
        """Delegates to repository."""
        expected = GraphState(node_count=5, edge_count=3)
        mock_repo.get_graph_state.return_value = expected

        result = await service.get_graph_state("s1")

        assert result == expected
        mock_repo.get_graph_state.assert_called_with("s1")


class TestHandleContradiction:
    """Tests for handle_contradiction."""

    @pytest.mark.asyncio
    async def test_creates_revises_edge(self, service, mock_repo):
        """Creates REVISES edge for contradiction."""
        new_node = KGNode(
            id="new", session_id="s1", label="new belief",
            node_type="attribute", source_utterance_ids=["u1"]
        )
        edge = KGEdge(
            id="e1", session_id="s1", source_node_id="new",
            target_node_id="old", edge_type="revises", source_utterance_ids=["u1"]
        )

        mock_repo.create_node.return_value = new_node
        mock_repo.supersede_node.return_value = None
        mock_repo.create_edge.return_value = edge

        result_node, result_edge = await service.handle_contradiction(
            session_id="s1",
            old_node_id="old",
            new_concept=ExtractedConcept(text="new belief", node_type="attribute"),
            utterance_id="u1",
        )

        assert result_node.id == "new"
        assert result_edge.edge_type == "revises"
        mock_repo.supersede_node.assert_called_with("old", "new")
```

## Requirements
1. Must use GraphRepository for all persistence (no direct SQL)
2. Deduplication by exact label match (case-insensitive)
3. Must track provenance (source utterance IDs)
4. Must handle contradictions with REVISES edges
5. Must log all significant operations
6. Business logic only - no direct database access

## Verification
```bash
# Run graph service tests
pytest tests/unit/test_graph_service.py -v

# Verify imports
python3 -c "from src.services.graph_service import GraphService; print('Graph service imported')"
```

## Success Criteria
- [ ] `GraphService` class with repository injection
- [ ] `add_extraction_to_graph()` converts extraction to nodes/edges
- [ ] Node deduplication by label match
- [ ] Edge deduplication by source/target/type
- [ ] Provenance tracking via source_utterance_ids
- [ ] `handle_contradiction()` creates REVISES edges
- [ ] `get_session_graph()` returns full graph
- [ ] `get_graph_state()` returns GraphState for scoring
- [ ] All tests pass with mocked repository
