# Spec 2.5: Graph Repository

## Objective
Create the repository layer for knowledge graph persistence (nodes and edges) using aiosqlite.

## Context
- Reference: ENGINEERING_GUIDE.md Section 8 (Database Schema), PRD Section 7.3
- v1 Reference: `src/modules/knowledge_graph_manager.py`
- Key change: asyncpg → aiosqlite, bi-temporal → single timestamp
- Repository pattern: Data access only, no business logic

## Input Files
- `ENGINEERING_GUIDE.md` - Section 8 (kg_nodes, kg_edges tables)
- `src/domain/models/knowledge_graph.py` - Models from spec 2.1
- `src/persistence/database.py` - Database module from Phase 1
- v1: `/home/mikhailarutyunov/projects/graph-enabled-ai-interviewer/src/modules/knowledge_graph_manager.py`

## Output Files

### src/persistence/repositories/graph_repo.py
```python
"""
Repository for knowledge graph persistence.

Handles CRUD operations on kg_nodes and kg_edges tables.
Uses aiosqlite for async SQLite access.

No business logic - that belongs in GraphService.
"""

import json
from datetime import datetime
from typing import List, Optional
from uuid import uuid4

import aiosqlite
import structlog

from src.domain.models.knowledge_graph import KGNode, KGEdge, GraphState

log = structlog.get_logger(__name__)


class GraphRepository:
    """
    Repository for knowledge graph nodes and edges.

    Provides CRUD operations on SQLite tables:
    - kg_nodes: Knowledge graph nodes
    - kg_edges: Knowledge graph edges
    """

    def __init__(self, db: aiosqlite.Connection):
        """
        Initialize graph repository.

        Args:
            db: aiosqlite connection (from FastAPI dependency)
        """
        self.db = db

    # ==================== NODE OPERATIONS ====================

    async def create_node(
        self,
        session_id: str,
        label: str,
        node_type: str,
        confidence: float = 0.8,
        properties: Optional[dict] = None,
        source_utterance_ids: Optional[List[str]] = None,
    ) -> KGNode:
        """
        Create a new knowledge graph node.

        Args:
            session_id: Session ID
            label: Node label (respondent's language)
            node_type: Node type (attribute, consequence, value)
            confidence: Extraction confidence (0.0-1.0)
            properties: Additional properties
            source_utterance_ids: IDs of source utterances

        Returns:
            Created KGNode
        """
        node_id = str(uuid4())
        now = datetime.utcnow().isoformat()
        properties = properties or {}
        source_ids = source_utterance_ids or []

        await self.db.execute(
            """
            INSERT INTO kg_nodes (
                id, session_id, label, node_type, confidence,
                properties, source_utterance_ids, recorded_at, superseded_by
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (
                node_id,
                session_id,
                label,
                node_type,
                confidence,
                json.dumps(properties),
                json.dumps(source_ids),
                now,
                None,
            ),
        )
        await self.db.commit()

        log.info("node_created", node_id=node_id, label=label, node_type=node_type)

        return await self.get_node(node_id)

    async def get_node(self, node_id: str) -> Optional[KGNode]:
        """
        Get a node by ID.

        Args:
            node_id: Node ID

        Returns:
            KGNode or None if not found
        """
        cursor = await self.db.execute(
            "SELECT * FROM kg_nodes WHERE id = ?",
            (node_id,),
        )
        row = await cursor.fetchone()

        if not row:
            return None

        return self._row_to_node(row)

    async def get_nodes_by_session(self, session_id: str) -> List[KGNode]:
        """
        Get all nodes for a session.

        Args:
            session_id: Session ID

        Returns:
            List of KGNode objects
        """
        cursor = await self.db.execute(
            "SELECT * FROM kg_nodes WHERE session_id = ? AND superseded_by IS NULL",
            (session_id,),
        )
        rows = await cursor.fetchall()

        return [self._row_to_node(row) for row in rows]

    async def find_node_by_label(
        self, session_id: str, label: str
    ) -> Optional[KGNode]:
        """
        Find a node by exact label match (case-insensitive).

        Args:
            session_id: Session ID
            label: Node label to find

        Returns:
            KGNode or None if not found
        """
        cursor = await self.db.execute(
            """
            SELECT * FROM kg_nodes
            WHERE session_id = ? AND LOWER(label) = LOWER(?) AND superseded_by IS NULL
            """,
            (session_id, label),
        )
        row = await cursor.fetchone()

        if not row:
            return None

        return self._row_to_node(row)

    async def update_node(
        self,
        node_id: str,
        **updates,
    ) -> Optional[KGNode]:
        """
        Update a node's fields.

        Args:
            node_id: Node ID
            **updates: Fields to update (confidence, properties, etc.)

        Returns:
            Updated KGNode or None if not found
        """
        # Build update query
        set_clauses = []
        values = []

        for field, value in updates.items():
            if field in ("confidence", "superseded_by"):
                set_clauses.append(f"{field} = ?")
                values.append(value)
            elif field == "properties":
                set_clauses.append("properties = ?")
                values.append(json.dumps(value))
            elif field == "source_utterance_ids":
                set_clauses.append("source_utterance_ids = ?")
                values.append(json.dumps(value))

        if not set_clauses:
            return await self.get_node(node_id)

        values.append(node_id)
        query = f"UPDATE kg_nodes SET {', '.join(set_clauses)} WHERE id = ?"

        await self.db.execute(query, values)
        await self.db.commit()

        log.info("node_updated", node_id=node_id, updates=list(updates.keys()))

        return await self.get_node(node_id)

    async def add_source_utterance(
        self, node_id: str, utterance_id: str
    ) -> Optional[KGNode]:
        """
        Add a source utterance to a node's provenance.

        Args:
            node_id: Node ID
            utterance_id: Utterance ID to add

        Returns:
            Updated KGNode or None if not found
        """
        node = await self.get_node(node_id)
        if not node:
            return None

        source_ids = list(node.source_utterance_ids)
        if utterance_id not in source_ids:
            source_ids.append(utterance_id)
            return await self.update_node(node_id, source_utterance_ids=source_ids)

        return node

    async def supersede_node(
        self, old_node_id: str, new_node_id: str
    ) -> Optional[KGNode]:
        """
        Mark a node as superseded by another (for contradictions).

        Args:
            old_node_id: Node being superseded
            new_node_id: Node that supersedes it

        Returns:
            Updated old node or None
        """
        return await self.update_node(old_node_id, superseded_by=new_node_id)

    # ==================== EDGE OPERATIONS ====================

    async def create_edge(
        self,
        session_id: str,
        source_node_id: str,
        target_node_id: str,
        edge_type: str,
        confidence: float = 0.8,
        properties: Optional[dict] = None,
        source_utterance_ids: Optional[List[str]] = None,
    ) -> KGEdge:
        """
        Create a new knowledge graph edge.

        Args:
            session_id: Session ID
            source_node_id: Source node ID
            target_node_id: Target node ID
            edge_type: Edge type (leads_to, revises)
            confidence: Extraction confidence
            properties: Additional properties
            source_utterance_ids: IDs of source utterances

        Returns:
            Created KGEdge
        """
        edge_id = str(uuid4())
        now = datetime.utcnow().isoformat()
        properties = properties or {}
        source_ids = source_utterance_ids or []

        await self.db.execute(
            """
            INSERT INTO kg_edges (
                id, session_id, source_node_id, target_node_id, edge_type,
                confidence, properties, source_utterance_ids, recorded_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
            (
                edge_id,
                session_id,
                source_node_id,
                target_node_id,
                edge_type,
                confidence,
                json.dumps(properties),
                json.dumps(source_ids),
                now,
            ),
        )
        await self.db.commit()

        log.info(
            "edge_created",
            edge_id=edge_id,
            source=source_node_id,
            target=target_node_id,
            type=edge_type,
        )

        return await self.get_edge(edge_id)

    async def get_edge(self, edge_id: str) -> Optional[KGEdge]:
        """
        Get an edge by ID.

        Args:
            edge_id: Edge ID

        Returns:
            KGEdge or None if not found
        """
        cursor = await self.db.execute(
            "SELECT * FROM kg_edges WHERE id = ?",
            (edge_id,),
        )
        row = await cursor.fetchone()

        if not row:
            return None

        return self._row_to_edge(row)

    async def get_edges_by_session(self, session_id: str) -> List[KGEdge]:
        """
        Get all edges for a session.

        Args:
            session_id: Session ID

        Returns:
            List of KGEdge objects
        """
        cursor = await self.db.execute(
            "SELECT * FROM kg_edges WHERE session_id = ?",
            (session_id,),
        )
        rows = await cursor.fetchall()

        return [self._row_to_edge(row) for row in rows]

    async def find_edge(
        self,
        session_id: str,
        source_node_id: str,
        target_node_id: str,
        edge_type: str,
    ) -> Optional[KGEdge]:
        """
        Find an edge by source, target, and type.

        Args:
            session_id: Session ID
            source_node_id: Source node ID
            target_node_id: Target node ID
            edge_type: Edge type

        Returns:
            KGEdge or None if not found
        """
        cursor = await self.db.execute(
            """
            SELECT * FROM kg_edges
            WHERE session_id = ? AND source_node_id = ?
              AND target_node_id = ? AND edge_type = ?
            """,
            (session_id, source_node_id, target_node_id, edge_type),
        )
        row = await cursor.fetchone()

        if not row:
            return None

        return self._row_to_edge(row)

    async def add_edge_source_utterance(
        self, edge_id: str, utterance_id: str
    ) -> Optional[KGEdge]:
        """
        Add a source utterance to an edge's provenance.

        Args:
            edge_id: Edge ID
            utterance_id: Utterance ID to add

        Returns:
            Updated KGEdge or None
        """
        edge = await self.get_edge(edge_id)
        if not edge:
            return None

        source_ids = list(edge.source_utterance_ids)
        if utterance_id not in source_ids:
            source_ids.append(utterance_id)

            await self.db.execute(
                "UPDATE kg_edges SET source_utterance_ids = ? WHERE id = ?",
                (json.dumps(source_ids), edge_id),
            )
            await self.db.commit()

        return await self.get_edge(edge_id)

    # ==================== GRAPH STATE ====================

    async def get_graph_state(self, session_id: str) -> GraphState:
        """
        Get aggregate graph statistics for a session.

        Args:
            session_id: Session ID

        Returns:
            GraphState with counts and metrics
        """
        # Node count
        cursor = await self.db.execute(
            "SELECT COUNT(*) FROM kg_nodes WHERE session_id = ? AND superseded_by IS NULL",
            (session_id,),
        )
        node_count = (await cursor.fetchone())[0]

        # Edge count
        cursor = await self.db.execute(
            "SELECT COUNT(*) FROM kg_edges WHERE session_id = ?",
            (session_id,),
        )
        edge_count = (await cursor.fetchone())[0]

        # Nodes by type
        cursor = await self.db.execute(
            """
            SELECT node_type, COUNT(*) FROM kg_nodes
            WHERE session_id = ? AND superseded_by IS NULL
            GROUP BY node_type
            """,
            (session_id,),
        )
        nodes_by_type = {row[0]: row[1] for row in await cursor.fetchall()}

        # Edges by type
        cursor = await self.db.execute(
            """
            SELECT edge_type, COUNT(*) FROM kg_edges
            WHERE session_id = ?
            GROUP BY edge_type
            """,
            (session_id,),
        )
        edges_by_type = {row[0]: row[1] for row in await cursor.fetchall()}

        # Orphan nodes (no edges)
        cursor = await self.db.execute(
            """
            SELECT COUNT(*) FROM kg_nodes n
            WHERE n.session_id = ? AND n.superseded_by IS NULL
              AND NOT EXISTS (
                  SELECT 1 FROM kg_edges e
                  WHERE e.session_id = ?
                    AND (e.source_node_id = n.id OR e.target_node_id = n.id)
              )
            """,
            (session_id, session_id),
        )
        orphan_count = (await cursor.fetchone())[0]

        # Max depth (simplified: just count depth levels)
        # Full graph traversal would be expensive; use node type as proxy
        max_depth = len([t for t in nodes_by_type if nodes_by_type.get(t, 0) > 0])

        return GraphState(
            node_count=node_count,
            edge_count=edge_count,
            nodes_by_type=nodes_by_type,
            edges_by_type=edges_by_type,
            orphan_count=orphan_count,
            max_depth=max_depth,
        )

    # ==================== HELPERS ====================

    def _row_to_node(self, row: aiosqlite.Row) -> KGNode:
        """Convert database row to KGNode."""
        return KGNode(
            id=row["id"],
            session_id=row["session_id"],
            label=row["label"],
            node_type=row["node_type"],
            confidence=row["confidence"],
            properties=json.loads(row["properties"]) if row["properties"] else {},
            source_utterance_ids=json.loads(row["source_utterance_ids"]) if row["source_utterance_ids"] else [],
            recorded_at=datetime.fromisoformat(row["recorded_at"]),
            superseded_by=row["superseded_by"],
        )

    def _row_to_edge(self, row: aiosqlite.Row) -> KGEdge:
        """Convert database row to KGEdge."""
        return KGEdge(
            id=row["id"],
            session_id=row["session_id"],
            source_node_id=row["source_node_id"],
            target_node_id=row["target_node_id"],
            edge_type=row["edge_type"],
            confidence=row["confidence"],
            properties=json.loads(row["properties"]) if row["properties"] else {},
            source_utterance_ids=json.loads(row["source_utterance_ids"]) if row["source_utterance_ids"] else [],
            recorded_at=datetime.fromisoformat(row["recorded_at"]),
        )
```

### tests/unit/test_graph_repo.py
```python
"""Tests for graph repository."""

import pytest
import tempfile
from pathlib import Path

import aiosqlite

from src.persistence.database import init_database
from src.persistence.repositories.graph_repo import GraphRepository


@pytest.fixture
async def db_connection():
    """Create test database with schema."""
    with tempfile.TemporaryDirectory() as tmpdir:
        db_path = Path(tmpdir) / "test.db"
        await init_database(db_path)

        async with aiosqlite.connect(db_path) as db:
            db.row_factory = aiosqlite.Row
            yield db


@pytest.fixture
async def repo(db_connection):
    """Create graph repository with test database."""
    return GraphRepository(db_connection)


@pytest.fixture
async def session_id(db_connection):
    """Create a test session and return its ID."""
    session_id = "test-session-1"
    await db_connection.execute(
        """
        INSERT INTO sessions (id, methodology, concept_id, status, config)
        VALUES (?, 'means_end_chain', 'test-concept', 'active', '{}')
        """,
        (session_id,),
    )
    await db_connection.commit()
    return session_id


class TestNodeOperations:
    """Tests for node CRUD operations."""

    @pytest.mark.asyncio
    async def test_create_node(self, repo, session_id):
        """create_node creates and returns a node."""
        node = await repo.create_node(
            session_id=session_id,
            label="creamy texture",
            node_type="attribute",
            confidence=0.9,
        )

        assert node.id is not None
        assert node.label == "creamy texture"
        assert node.node_type == "attribute"
        assert node.confidence == 0.9

    @pytest.mark.asyncio
    async def test_get_node(self, repo, session_id):
        """get_node retrieves a node by ID."""
        created = await repo.create_node(
            session_id=session_id,
            label="test",
            node_type="attribute",
        )

        retrieved = await repo.get_node(created.id)

        assert retrieved is not None
        assert retrieved.id == created.id
        assert retrieved.label == "test"

    @pytest.mark.asyncio
    async def test_get_node_not_found(self, repo):
        """get_node returns None for unknown ID."""
        result = await repo.get_node("nonexistent")
        assert result is None

    @pytest.mark.asyncio
    async def test_get_nodes_by_session(self, repo, session_id):
        """get_nodes_by_session returns all session nodes."""
        await repo.create_node(session_id, "node1", "attribute")
        await repo.create_node(session_id, "node2", "functional_consequence")

        nodes = await repo.get_nodes_by_session(session_id)

        assert len(nodes) == 2

    @pytest.mark.asyncio
    async def test_find_node_by_label(self, repo, session_id):
        """find_node_by_label finds by exact label."""
        await repo.create_node(session_id, "Creamy Texture", "attribute")

        # Case-insensitive match
        found = await repo.find_node_by_label(session_id, "creamy texture")

        assert found is not None
        assert found.label == "Creamy Texture"

    @pytest.mark.asyncio
    async def test_find_node_by_label_not_found(self, repo, session_id):
        """find_node_by_label returns None if not found."""
        result = await repo.find_node_by_label(session_id, "nonexistent")
        assert result is None

    @pytest.mark.asyncio
    async def test_supersede_node(self, repo, session_id):
        """supersede_node marks node as superseded."""
        old = await repo.create_node(session_id, "old belief", "attribute")
        new = await repo.create_node(session_id, "new belief", "attribute")

        updated = await repo.supersede_node(old.id, new.id)

        assert updated.superseded_by == new.id


class TestEdgeOperations:
    """Tests for edge CRUD operations."""

    @pytest.mark.asyncio
    async def test_create_edge(self, repo, session_id):
        """create_edge creates and returns an edge."""
        node1 = await repo.create_node(session_id, "source", "attribute")
        node2 = await repo.create_node(session_id, "target", "functional_consequence")

        edge = await repo.create_edge(
            session_id=session_id,
            source_node_id=node1.id,
            target_node_id=node2.id,
            edge_type="leads_to",
            confidence=0.85,
        )

        assert edge.id is not None
        assert edge.source_node_id == node1.id
        assert edge.target_node_id == node2.id
        assert edge.edge_type == "leads_to"

    @pytest.mark.asyncio
    async def test_find_edge(self, repo, session_id):
        """find_edge finds by source, target, type."""
        node1 = await repo.create_node(session_id, "a", "attribute")
        node2 = await repo.create_node(session_id, "b", "functional_consequence")
        await repo.create_edge(session_id, node1.id, node2.id, "leads_to")

        found = await repo.find_edge(session_id, node1.id, node2.id, "leads_to")

        assert found is not None
        assert found.source_node_id == node1.id

    @pytest.mark.asyncio
    async def test_get_edges_by_session(self, repo, session_id):
        """get_edges_by_session returns all session edges."""
        n1 = await repo.create_node(session_id, "a", "attribute")
        n2 = await repo.create_node(session_id, "b", "functional_consequence")
        n3 = await repo.create_node(session_id, "c", "psychosocial_consequence")

        await repo.create_edge(session_id, n1.id, n2.id, "leads_to")
        await repo.create_edge(session_id, n2.id, n3.id, "leads_to")

        edges = await repo.get_edges_by_session(session_id)

        assert len(edges) == 2


class TestGraphState:
    """Tests for graph state aggregation."""

    @pytest.mark.asyncio
    async def test_get_graph_state_empty(self, repo, session_id):
        """get_graph_state returns zeros for empty graph."""
        state = await repo.get_graph_state(session_id)

        assert state.node_count == 0
        assert state.edge_count == 0

    @pytest.mark.asyncio
    async def test_get_graph_state_with_data(self, repo, session_id):
        """get_graph_state returns correct counts."""
        n1 = await repo.create_node(session_id, "a", "attribute")
        n2 = await repo.create_node(session_id, "b", "functional_consequence")
        await repo.create_edge(session_id, n1.id, n2.id, "leads_to")

        state = await repo.get_graph_state(session_id)

        assert state.node_count == 2
        assert state.edge_count == 1
        assert state.nodes_by_type["attribute"] == 1
        assert state.edges_by_type["leads_to"] == 1

    @pytest.mark.asyncio
    async def test_get_graph_state_orphans(self, repo, session_id):
        """get_graph_state counts orphan nodes."""
        await repo.create_node(session_id, "orphan", "attribute")  # No edges

        state = await repo.get_graph_state(session_id)

        assert state.orphan_count == 1
```

## Requirements
1. Must use aiosqlite (not asyncpg)
2. Must match schema from ENGINEERING_GUIDE.md Section 8
3. JSON fields (properties, source_utterance_ids) must serialize/deserialize correctly
4. Case-insensitive label matching for deduplication
5. Must track supersession via `superseded_by` field (not bi-temporal)
6. Must log all create/update operations
7. Repository has no business logic - just data access

## Verification
```bash
# Run graph repo tests
pytest tests/unit/test_graph_repo.py -v

# Verify imports
python3 -c "from src.persistence.repositories.graph_repo import GraphRepository; print('Graph repo imported')"
```

## Success Criteria
- [ ] `GraphRepository` class with db connection injection
- [ ] Node CRUD: create_node, get_node, get_nodes_by_session, find_node_by_label
- [ ] Edge CRUD: create_edge, get_edge, get_edges_by_session, find_edge
- [ ] `supersede_node()` for contradiction handling
- [ ] `add_source_utterance()` for provenance tracking
- [ ] `get_graph_state()` returns GraphState with counts
- [ ] JSON fields correctly serialized/deserialized
- [ ] All tests pass
