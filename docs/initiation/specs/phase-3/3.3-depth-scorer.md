# Spec 3.3: Depth Scorer

## Objective
Create the depth scorer to balance depth vs breadth based on interview phase.

## Context
- Reference: PRD Section 5.2.3 (Depth strategies), IMPLEMENTATION_PLAN.md Section 3.3
- v1 Reference: `/home/mikhailarutyunov/projects/graph-enabled-ai-interviewer/src/modules/scorers/depth_breadth_phase_scorer.py`
- Simplifies v1: Combines depth/breadth/phase into single scorer
- Uses graph_state.max_depth as key metric

## Input Files
- `src/services/scoring/base.py` - From spec 3.1
- `src/domain/models/knowledge_graph.py` - GraphState with max_depth field
- v1: `/home/mikhailarutyunov/projects/graph-enabled-ai-interviewer/src/modules/scorers/depth_breadth_phase_scorer.py`

## Output Files

### src/services/scoring/depth.py
```python
"""Depth scorer - balances depth vs breadth based on interview phase.

Boosts depth in late phase, breadth in early phase.
"""

from typing import Any, Dict, List

import structlog

from src.domain.models.knowledge_graph import GraphState
from src.services.scoring.base import ScorerBase, ScorerOutput


logger = structlog.get_logger(__name__)


class DepthScorer(ScorerBase):
    """
    Balance depth vs breadth based on interview phase.

    Algorithm:
    1. Calculate phase: turn_count / estimated_total_turns
    2. Early phase (< 0.3): boost breadth
    3. Middle phase (0.3-0.7): neutral
    4. Late phase (> 0.7): boost depth for chain completion

    Scoring:
    - 1.0 = neutral (middle phase)
    - early_breadth_boost (e.g., 1.5) = early phase, boost breadth
    - late_depth_boost (e.g., 1.4) = late phase, boost depth

    Configuration parameters:
    - early_breadth_boost: Boost for breadth in early phase (default: 1.5)
    - late_depth_boost: Boost for depth in late phase (default: 1.4)
    - phase_thresholds: [early_end, late_start] (default: [0.3, 0.7])
    - estimated_total_turns: Expected interview length (default: 20)
    """

    def __init__(self, config: Dict[str, Any] = None):
        super().__init__(config)
        self.early_breadth_boost = self.params.get("early_breadth_boost", 1.5)
        self.late_depth_boost = self.params.get("late_depth_boost", 1.4)
        self.phase_thresholds = self.params.get("phase_thresholds", [0.3, 0.7])
        self.estimated_total = self.params.get("estimated_total_turns", 20)

    async def score(
        self,
        strategy: Dict[str, Any],
        focus: Dict[str, Any],
        graph_state: GraphState,
        recent_nodes: List[Dict[str, Any]],
    ) -> ScorerOutput:
        """
        Score based on interview phase.

        Args:
            strategy: Strategy dict with 'type_category'
            focus: Focus dict (unused for depth scorer)
            graph_state: Graph state with turn_count and max_depth
            recent_nodes: Recent nodes (unused for depth scorer)

        Returns:
            ScorerOutput with phase-based score
        """
        score = 1.0
        signals = {}
        reasons = []

        # Calculate phase
        turn_count = graph_state.properties.get("turn_count", 1)
        phase = turn_count / self.estimated_total

        signals["turn_count"] = turn_count
        signals["phase"] = phase
        signals["max_depth"] = graph_state.max_depth

        # Determine phase category
        early_threshold, late_threshold = self.phase_thresholds
        is_early = phase < early_threshold
        is_middle = early_threshold <= phase <= late_threshold
        is_late = phase > late_threshold

        signals["is_early"] = is_early
        signals["is_middle"] = is_middle
        signals["is_late"] = is_late

        # Apply phase-based adjustments
        if is_early:
            # Early phase: boost breadth/coverage
            if strategy.get("type_category") in ["breadth", "coverage"]:
                score *= self.early_breadth_boost
                reasons.append(
                    f"Early phase (turn {turn_count}/{self.estimated_total}) - breadth encouraged"
                )

        elif is_late:
            # Late phase: boost depth for chain completion
            if strategy.get("type_category") == "depth":
                score *= self.late_depth_boost
                reasons.append(
                    f"Late phase (turn {turn_count}/{self.estimated_total}) - depth encouraged"
                )

        if not reasons:
            reasoning = f"Middle phase (turn {turn_count}/{self.estimated_total})"
        else:
            reasoning = "; ".join(reasons)

        logger.debug(
            "DepthScorer output",
            strategy_id=strategy.get("id"),
            phase=phase,
            score=score,
        )

        return self.make_output(score, signals, reasoning)
```

## Requirements
1. Extends ScorerBase
2. Reads turn_count from graph_state.properties
3. Uses max_depth from graph_state for signal tracking
4. Boosts breadth in early phase, depth in late phase
5. Phase thresholds configurable

## Verification
```bash
# Run tests
pytest tests/unit/test_depth_scorer.py -v

# Verify import
python3 -c "from src.services.scoring.depth import DepthScorer; print('OK')"
```

## Success Criteria
- [ ] `DepthScorer` class extends `ScorerBase`
- [ ] Calculates phase from turn_count / estimated_total_turns
- [ ] Boosts breadth strategies in early phase
- [ ] Boosts depth strategies in late phase
- [ ] Returns 1.0 in middle phase
- [ ] All tests pass
