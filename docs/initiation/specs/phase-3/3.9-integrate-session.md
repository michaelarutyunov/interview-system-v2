# Spec 3.9: Integrate Scoring into Session Service

## Objective
Integrate the strategy service into the session service for adaptive strategy selection.

## Context
- Reference: PRD Section 4.1 (Interview Conduction), IMPLEMENTATION_PLAN.md Section 3.9
- Updates: `src/services/session_service.py` from Phase 2 (spec 2.9)
- Replaces hardcoded "deepen" strategy with adaptive selection
- Adds scoring output to TurnResult

## Input Files
- `src/services/session_service.py` - From spec 2.9
- `src/services/strategy_service.py` - From spec 3.8
- Phase 2: Session service with hardcoded strategy

## Output Files

### Updated src/services/session_service.py

Additions to the session service:

```python
# Add imports
from src.services.strategy_service import StrategyService, SelectionResult

# Update SessionService.__init__ to accept strategy_service
class SessionService:
    def __init__(
        self,
        session_repo: SessionRepository,
        graph_repo: GraphRepository,
        extraction_service: ExtractionService,
        graph_service: GraphService,
        question_service: QuestionService,
        strategy_service: StrategyService,  # NEW
    ):
        self.session_repo = session_repo
        self.graph_repo = graph_repo
        self.extraction_service = extraction_service
        self.graph_service = graph_service
        self.question_service = question_service
        self.strategy_service = strategy_service  # NEW
        self.log = structlog.get_logger(__name__)

# Update TurnResult to include scoring
@dataclass
class TurnResult:
    """
    Result of processing a single turn.

    Matches PRD Section 8.6 response structure.
    """
    turn_number: int
    extracted: Dict[str, Any]  # concepts, relationships
    graph_state: Dict[str, Any]  # node_count, edge_count, depth_achieved
    scoring: Dict[str, Any]  # NEW: strategy, score, reasoning
    strategy_selected: str  # NEW: strategy ID
    next_question: str
    should_continue: bool
    latency_ms: int = 0

# Update process_turn to use strategy selection
async def process_turn(
    self,
    session_id: str,
    user_input: str,
) -> TurnResult:
    """
    Process a single interview turn.

    Updated to use adaptive strategy selection.
    """
    start_time = time.time()
    self.log.info("Processing turn", session_id=session_id)

    # 1. Load session context
    context = await self._load_context(session_id)

    # 2. Save user utterance
    user_utterance = await self._save_utterance(
        session_id, context.turn_number, "user", user_input
    )

    # 3. Extract concepts and relationships
    extraction = await self.extraction_service.extract(
        user_input, context.methodology
    )

    # 4. Update knowledge graph
    await self.graph_service.update_graph(
        session_id, extraction, context.turn_number
    )

    # 5. Refresh graph state
    graph_state = await self.graph_service.get_state(session_id)

    # 6. Get recent nodes for novelty scoring
    recent_nodes = await self.graph_repo.get_recent_nodes(
        session_id, limit=5
    )

    # 7. Select strategy (NEW - was hardcoded "deepen")
    selection = await self.strategy_service.select(
        graph_state, [n.dict() for n in recent_nodes]
    )

    self.log.info(
        "Strategy selected",
        strategy_id=selection.selected_strategy["id"],
        score=selection.final_score,
    )

    # 8. Generate follow-up question using selected strategy
    question = await self.question_service.generate(
        context=context,
        extraction=extraction,
        graph_state=graph_state,
        strategy=selection.selected_strategy,
        focus=selection.selected_focus,
    )

    # 9. Save system utterance
    await self._save_utterance(
        session_id, context.turn_number + 1, "system", question
    )

    # 10. Build result
    latency_ms = int((time.time() - start_time) * 1000)

    return TurnResult(
        turn_number=context.turn_number,
        extracted={
            "concepts": [c.dict() for c in extraction.concepts],
            "relationships": [r.dict() for r in extraction.relationships],
        },
        graph_state={
            "node_count": graph_state.node_count,
            "edge_count": graph_state.edge_count,
            "max_depth": graph_state.max_depth,
            "nodes_by_type": graph_state.nodes_by_type,
        },
        scoring={  # NEW
            "strategy_id": selection.selected_strategy["id"],
            "strategy_name": selection.selected_strategy["name"],
            "focus_type": selection.selected_focus.get("focus_type"),
            "final_score": selection.final_score,
            "reasoning": selection.scoring_reasoning[-3:] if selection.scoring_reasoning else [],  # Last 3 steps
        },
        strategy_selected=selection.selected_strategy["id"],  # NEW
        next_question=question,
        should_continue=self._should_continue(graph_state),
        latency_ms=latency_ms,
    )

# Helper to get recent nodes (add to SessionService)
async def _get_recent_nodes(
    self,
    session_id: str,
    limit: int = 5,
) -> List[Dict[str, Any]]:
    """Get recent nodes for novelty scoring."""
    nodes = await self.graph_repo.get_recent_nodes(session_id, limit=limit)
    return [n.dict() for n in nodes]
```

## Requirements
1. Add `strategy_service` parameter to SessionService.__init__
2. Replace hardcoded strategy with `strategy_service.select()`
3. Update TurnResult to include scoring dict
4. Pass selected strategy and focus to question_service.generate()
5. Add `_get_recent_nodes()` helper for novelty scorer

## Verification
```bash
# Run integration test
pytest tests/integration/test_session_flow.py -v

# Run unit tests
pytest tests/unit/test_session_service.py -v
```

## Success Criteria
- [ ] SessionService accepts strategy_service in __init__
- [ ] process_turn calls strategy_service.select()
- [ ] TurnResult includes scoring dict with strategy_id, score, reasoning
- [ ] question_service.generate() receives strategy and focus
- [ ] All tests pass
