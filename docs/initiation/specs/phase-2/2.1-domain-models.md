# Spec 2.1: Domain Models

## Objective
Create domain models for knowledge graph nodes, edges, utterances, and extraction results.

## Context
- Reference: PRD Section 7 (Dual Graph Architecture), ENGINEERING_GUIDE.md Section 3
- v1 Reference: `src/models/knowledge_graph.py`, `src/models/extraction.py`
- Key simplification: Remove bi-temporal versioning (4 timestamps â†’ 1 `recorded_at`)
- Session model already exists from Phase 1

## Input Files
- `PRD.md` - Section 7.3 (Knowledge Graph schema)
- `ENGINEERING_GUIDE.md` - Section 3 (domain/models structure)
- v1: `/home/mikhailarutyunov/projects/graph-enabled-ai-interviewer/src/models/knowledge_graph.py`
- v1: `/home/mikhailarutyunov/projects/graph-enabled-ai-interviewer/src/models/extraction.py`

## Output Files

### src/domain/models/knowledge_graph.py
```python
"""Domain models for knowledge graph nodes and edges."""

from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum


class NodeType(str, Enum):
    """Valid node types for Means-End Chain methodology."""
    ATTRIBUTE = "attribute"
    FUNCTIONAL_CONSEQUENCE = "functional_consequence"
    PSYCHOSOCIAL_CONSEQUENCE = "psychosocial_consequence"
    INSTRUMENTAL_VALUE = "instrumental_value"
    TERMINAL_VALUE = "terminal_value"


class EdgeType(str, Enum):
    """Valid edge types."""
    LEADS_TO = "leads_to"
    REVISES = "revises"


class KGNode(BaseModel):
    """A node in the knowledge graph.

    Simplified from v1: Single timestamp instead of bi-temporal versioning.
    """
    id: str
    session_id: str
    label: str
    node_type: str  # One of NodeType values
    confidence: float = Field(default=0.8, ge=0.0, le=1.0)
    properties: Dict[str, Any] = Field(default_factory=dict)
    source_utterance_ids: List[str] = Field(default_factory=list)
    recorded_at: datetime = Field(default_factory=datetime.utcnow)
    superseded_by: Optional[str] = None  # Node ID that supersedes this one (for REVISES)

    class Config:
        from_attributes = True


class KGEdge(BaseModel):
    """A relationship in the knowledge graph."""
    id: str
    session_id: str
    source_node_id: str
    target_node_id: str
    edge_type: str  # One of EdgeType values
    confidence: float = Field(default=0.8, ge=0.0, le=1.0)
    properties: Dict[str, Any] = Field(default_factory=dict)
    source_utterance_ids: List[str] = Field(default_factory=list)
    recorded_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        from_attributes = True


class GraphState(BaseModel):
    """Current state of the knowledge graph for a session."""
    node_count: int = 0
    edge_count: int = 0
    nodes_by_type: Dict[str, int] = Field(default_factory=dict)
    edges_by_type: Dict[str, int] = Field(default_factory=dict)
    max_depth: int = 0  # Longest chain from attribute to value
    orphan_count: int = 0  # Nodes with no edges
```

### src/domain/models/utterance.py
```python
"""Domain model for utterances (conversation turns)."""

from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import datetime
from enum import Enum


class Speaker(str, Enum):
    """Who produced the utterance."""
    USER = "user"
    SYSTEM = "system"


class Utterance(BaseModel):
    """A single turn in the conversation.

    Stored in utterances table, used for provenance tracking.
    """
    id: str
    session_id: str
    turn_number: int
    speaker: str  # "user" or "system"
    text: str
    discourse_markers: List[str] = Field(default_factory=list)
    created_at: datetime = Field(default_factory=datetime.utcnow)

    class Config:
        from_attributes = True
```

### src/domain/models/extraction.py
```python
"""Domain models for extraction results."""

from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional


class ExtractedConcept(BaseModel):
    """A concept extracted from user text.

    Represents a potential knowledge graph node before deduplication.
    """
    text: str  # Original text from user
    node_type: str  # Suggested type (attribute, consequence, value)
    confidence: float = Field(default=0.8, ge=0.0, le=1.0)
    source_quote: str = ""  # Verbatim quote from utterance
    properties: Dict[str, Any] = Field(default_factory=dict)


class ExtractedRelationship(BaseModel):
    """A relationship extracted from user text.

    Links two extracted concepts.
    """
    source_text: str  # Source concept text
    target_text: str  # Target concept text
    relationship_type: str  # "leads_to" or "revises"
    confidence: float = Field(default=0.7, ge=0.0, le=1.0)
    source_quote: str = ""


class ExtractionResult(BaseModel):
    """Complete extraction result from a single utterance.

    Contains all concepts and relationships extracted from user input.
    """
    concepts: List[ExtractedConcept] = Field(default_factory=list)
    relationships: List[ExtractedRelationship] = Field(default_factory=list)
    discourse_markers: List[str] = Field(default_factory=list)  # "because", "so", etc.
    is_extractable: bool = True
    extractability_reason: Optional[str] = None
    latency_ms: int = 0
```

### src/domain/models/__init__.py
```python
"""Domain models package."""

from .session import Session, SessionStatus, SessionConfig
from .knowledge_graph import KGNode, KGEdge, GraphState, NodeType, EdgeType
from .utterance import Utterance, Speaker
from .extraction import ExtractedConcept, ExtractedRelationship, ExtractionResult

__all__ = [
    "Session",
    "SessionStatus",
    "SessionConfig",
    "KGNode",
    "KGEdge",
    "GraphState",
    "NodeType",
    "EdgeType",
    "Utterance",
    "Speaker",
    "ExtractedConcept",
    "ExtractedRelationship",
    "ExtractionResult",
]
```

### tests/unit/test_models.py
```python
"""Tests for domain models."""

import pytest
from datetime import datetime

from src.domain.models import (
    KGNode, KGEdge, GraphState,
    Utterance, Speaker,
    ExtractedConcept, ExtractedRelationship, ExtractionResult,
)


class TestKGNode:
    """Tests for KGNode model."""

    def test_create_valid_node(self):
        """KGNode can be created with valid data."""
        node = KGNode(
            id="node-1",
            session_id="session-1",
            label="creamy texture",
            node_type="attribute",
            confidence=0.9,
            source_utterance_ids=["utt-1"],
        )

        assert node.id == "node-1"
        assert node.label == "creamy texture"
        assert node.node_type == "attribute"
        assert node.confidence == 0.9
        assert node.superseded_by is None

    def test_node_defaults(self):
        """KGNode has sensible defaults."""
        node = KGNode(
            id="node-1",
            session_id="session-1",
            label="test",
            node_type="attribute",
        )

        assert node.confidence == 0.8
        assert node.properties == {}
        assert node.source_utterance_ids == []
        assert node.superseded_by is None

    def test_confidence_bounds(self):
        """Confidence must be between 0 and 1."""
        with pytest.raises(ValueError):
            KGNode(
                id="n1", session_id="s1", label="test",
                node_type="attribute", confidence=1.5
            )

        with pytest.raises(ValueError):
            KGNode(
                id="n1", session_id="s1", label="test",
                node_type="attribute", confidence=-0.1
            )


class TestKGEdge:
    """Tests for KGEdge model."""

    def test_create_valid_edge(self):
        """KGEdge can be created with valid data."""
        edge = KGEdge(
            id="edge-1",
            session_id="session-1",
            source_node_id="node-1",
            target_node_id="node-2",
            edge_type="leads_to",
            confidence=0.85,
        )

        assert edge.source_node_id == "node-1"
        assert edge.target_node_id == "node-2"
        assert edge.edge_type == "leads_to"


class TestUtterance:
    """Tests for Utterance model."""

    def test_create_user_utterance(self):
        """Utterance can be created for user input."""
        utt = Utterance(
            id="utt-1",
            session_id="session-1",
            turn_number=1,
            speaker="user",
            text="I like the creamy texture",
        )

        assert utt.speaker == "user"
        assert utt.turn_number == 1

    def test_create_system_utterance(self):
        """Utterance can be created for system response."""
        utt = Utterance(
            id="utt-2",
            session_id="session-1",
            turn_number=1,
            speaker="system",
            text="Why is that important to you?",
        )

        assert utt.speaker == "system"


class TestExtractionResult:
    """Tests for extraction result models."""

    def test_extraction_with_concepts(self):
        """ExtractionResult can hold concepts and relationships."""
        result = ExtractionResult(
            concepts=[
                ExtractedConcept(
                    text="creamy texture",
                    node_type="attribute",
                    confidence=0.9,
                    source_quote="I love the creamy texture",
                ),
                ExtractedConcept(
                    text="satisfying",
                    node_type="functional_consequence",
                    confidence=0.8,
                    source_quote="it's really satisfying",
                ),
            ],
            relationships=[
                ExtractedRelationship(
                    source_text="creamy texture",
                    target_text="satisfying",
                    relationship_type="leads_to",
                    confidence=0.75,
                ),
            ],
            discourse_markers=["because"],
        )

        assert len(result.concepts) == 2
        assert len(result.relationships) == 1
        assert "because" in result.discourse_markers

    def test_empty_extraction(self):
        """ExtractionResult can be empty for non-extractable input."""
        result = ExtractionResult(
            is_extractable=False,
            extractability_reason="Yes/no response",
        )

        assert result.concepts == []
        assert result.relationships == []
        assert not result.is_extractable


class TestGraphState:
    """Tests for GraphState model."""

    def test_empty_graph_state(self):
        """GraphState defaults to empty."""
        state = GraphState()

        assert state.node_count == 0
        assert state.edge_count == 0
        assert state.max_depth == 0

    def test_graph_state_with_data(self):
        """GraphState can hold aggregate data."""
        state = GraphState(
            node_count=5,
            edge_count=3,
            nodes_by_type={"attribute": 2, "functional_consequence": 3},
            max_depth=2,
            orphan_count=1,
        )

        assert state.node_count == 5
        assert state.nodes_by_type["attribute"] == 2
```

## Requirements
1. All models must use Pydantic v2 syntax (`model_config` not `Config` class where needed)
2. Confidence fields must have `ge=0.0, le=1.0` validation
3. Default values must be sensible (confidence=0.8, empty lists/dicts)
4. Models must support SQLite row conversion via `from_attributes = True`
5. No bi-temporal fields - use single `recorded_at` timestamp
6. Supersession handled via `superseded_by` field (not temporal ranges)

## Verification
```bash
# Run model tests
pytest tests/unit/test_models.py -v

# Verify imports work
python3 -c "from src.domain.models import KGNode, KGEdge, Utterance, ExtractionResult; print('Models imported successfully')"

# Verify Pydantic validation
python3 -c "
from src.domain.models import KGNode
try:
    KGNode(id='n1', session_id='s1', label='test', node_type='attr', confidence=1.5)
except ValueError as e:
    print('Validation working: confidence bounds enforced')
"
```

## Success Criteria
- [ ] `KGNode` model created with all fields from PRD Section 7.3
- [ ] `KGEdge` model created with source/target node references
- [ ] `Utterance` model created for conversation tracking
- [ ] `ExtractedConcept` and `ExtractedRelationship` models created
- [ ] `ExtractionResult` model aggregates extraction output
- [ ] `GraphState` model for graph metrics
- [ ] All models have `from_attributes = True` for ORM compatibility
- [ ] Confidence validation (0.0-1.0) works correctly
- [ ] `__init__.py` exports all models
- [ ] All tests pass
