# Spec 1.6: Session Repository

## Objective
Create a repository for session data persistence using aiosqlite, with methods for CRUD operations and session lifecycle management.

## Context
- Reference: IMPLEMENTATION_PLAN.md Section 2.2 (Task 1.6)
- Adapts v1 `session.py` models (180 lines) for v2 architecture
- Removes Redis dependencies, simplifies session state
- This enables the Phase 1 deliverable: `POST /sessions`, `GET /sessions/{id}`, `DELETE /sessions/{id}`

## Input Files
- `IMPLEMENTATION_PLAN.md` - Task 1.6 description
- v1 `src/models/session.py` - Reference for session models (if available)
- `ENGINEERING_GUIDE.md` - Repository pattern guidelines

## Output Files

### Session Models
Create `src/domain/models/session.py`:
```python
"""Session domain models."""
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, Field


class SessionState(BaseModel):
    """Current state of an interview session."""
    methodology: str  # e.g., "mec" (Means-End Chain), "zmet" (Zmet)
    concept_id: str
    concept_name: str
    turn_count: int = 0
    coverage_score: float = 0.0
    last_strategy: Optional[str] = None


class Session(BaseModel):
    """Interview session."""
    id: str
    methodology: str
    concept_id: str
    concept_name: str
    created_at: datetime
    updated_at: datetime
    state: SessionState
    status: str  # "active", "paused", "completed"
```

### Repository
Create `src/persistence/repositories/session_repo.py`:
```python
"""Session repository for database operations."""
import aiosqlite
from typing import Optional
from src.domain.models.session import Session, SessionState


class SessionRepository:
    """Repository for session CRUD operations."""

    def __init__(self, db_path: str):
        self.db_path = db_path

    async def create(self, session: Session) -> Session:
        """Create a new session."""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            await db.execute(
                "INSERT INTO sessions (id, methodology, concept_id, concept_name, status, created_at, updated_at) "
                "VALUES (?, ?, ?, ?, ?, datetime('now'), datetime('now'))",
                (session.id, session.methodology, session.concept_id,
                 session.concept_name, session.status)
            )
            return session

    async def get(self, session_id: str) -> Optional[Session]:
        """Get a session by ID."""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT * FROM sessions WHERE id = ?", (session_id,)
            )
            row = await cursor.fetchone()
            if not row:
                return None
            return Session(
                id=row["id"],
                methodology=row["methodology"],
                concept_id=row["concept_id"],
                concept_name=row["concept_name"],
                created_at=row["created_at"],
                updated_at=row["updated_at"],
                status=row["status"],
                state=SessionState(
                    methodology=row["methodology"],
                    concept_id=row["concept_id"],
                    concept_name=row["concept_name"],
                    turn_count=row["turn_count"],
                    coverage_score=row["coverage_score"],
                    last_strategy=row["last_strategy"]
                )
            )

    async def update_state(self, session_id: str, state: SessionState) -> None:
        """Update session state (computed on-demand, no caching)."""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute(
                "UPDATE sessions SET "
                "turn_count = ?, coverage_score = ?, last_strategy = ?, updated_at = datetime('now') "
                "WHERE id = ?",
                (state.turn_count, state.coverage_score,
                 state.last_strategy, session_id)
            )

    async def list_active(self) -> list[Session]:
        """List all active sessions."""
        async with aiosqlite.connect(self.db_path) as db:
            db.row_factory = aiosqlite.Row
            cursor = await db.execute(
                "SELECT * FROM sessions WHERE status = 'active' ORDER BY created_at DESC"
            )
            rows = await cursor.fetchall()
            return [
                Session(
                    id=row["id"],
                    methodology=row["methodology"],
                    concept_id=row["concept_id"],
                    concept_name=row["concept_name"],
                    created_at=row["created_at"],
                    updated_at=row["updated_at"],
                    status=row["status"],
                    state=SessionState(
                        methodology=row["methodology"],
                        concept_id=row["concept_id"],
                        concept_name=row["concept_name"],
                        turn_count=row["turn_count"],
                        coverage_score=row["coverage_score"],
                        last_strategy=row["last_strategy"]
                    )
                )
                for row in rows
            ]

    async def delete(self, session_id: str) -> bool:
        """Delete a session by ID. Returns True if deleted."""
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute(
                "DELETE FROM sessions WHERE id = ?", (session_id,)
            )
            return cursor.rowcount > 0
```

## Requirements

1. Repository must use aiosqlite for async database operations
2. Session state is computed on-demand from database, not cached
3. All methods must be async (sync wrappers not allowed)
4. Uses `aiosqlite.Row` for dict-like result access
5. Follows repository pattern from Engineering Guide

## Verification
```bash
# Check prerequisites
command -v python3 >/dev/null 2>&1 || pip3 install python3
python3 -c "import aiosqlite" 2>/dev/null || pip3 install aiosqlite

# Run tests
pytest tests/unit/test_session_repo.py -v
```

## Success Criteria
- [ ] `SessionRepository` class with async methods: create, get, update_state, list_active, delete
- [ ] Session models use Pydantic v2 with proper validation
- [ ] Repository methods use aiosqlite with proper row_factory
- [ ] All database operations are async (no sync wrappers)
- [ ] Tests pass: create, get, update_state, list_active, delete

## Dependencies
- Requires: Database schema from Spec 1.2
- Requires: Settings from Spec 1.4
- Used by: Spec 1.7 (Session API endpoints)
